<HTML>
<HEAD>
<BASE target="_top">
<TITLE>United States Patent: 8925090</TITLE></HEAD>
<!-BUF1=8925090
BUF7=2014
BUF8=78707
BUF9=/1/
BUF51=8
-->
<BODY bgcolor="#FFFFFF">
<A name="top"></A>
<CENTER>
<IMG src="/netaicon/PTO/patfthdr.gif" alt="[US Patent & Trademark Office, Patent Full Text and Image Database]">
<BR>
<TABLE>
<TR><TD align="center">
<A href="/netahtml/PTO/index.html"><IMG src="/netaicon/PTO/home.gif" alt="[Home]" border="0" valign="middle"></A>
<A href="/netahtml/PTO/search-bool.html"><IMG src="/netaicon/PTO/boolean.gif" alt="[Boolean Search]" border="0" valign="middle"></A>
<A href="/netahtml/PTO/search-adv.htm"><IMG border="0" src="/netaicon/PTO/manual.gif" ALT="[Manual Search]" valign="middle"></A>
<A href="/netahtml/PTO/srchnum.htm"><IMG src="/netaicon/PTO/number.gif" alt="[Number Search]" border="0" valign="middle"></A>
<A href="/netahtml/PTO/help/help.htm"><IMG border="0" valign="middle" src="/netaicon/PTO/help.gif" ALT="[Help]"></A>
</TD></TR>
<TR><TD align="center">
   <A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=640&f=S&l=50&d=PTXT&s1=((G06F.CPCL.+AND+(%22intrusion+prevention+system%22+OR+%22intrusion+detection+system%22))+AND+((power+OR+electricity)+OR+relay))&p=12&Query=CPCL/G06F+AND+(&quot;intrusion+prevention+system&quot;+OR+&quot;intrusion+detection+system&quot;)+AND+(power+or+electricity+or+relay)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/prevlist.gif border=0 ALT=[PREV_LIST]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=640&f=S&l=50&d=PTXT&s1=((G06F.CPCL.+AND+(%22intrusion+prevention+system%22+OR+%22intrusion+detection+system%22))+AND+((power+OR+electricity)+OR+relay))&p=13&Query=CPCL/G06F+AND+(&quot;intrusion+prevention+system&quot;+OR+&quot;intrusion+detection+system&quot;)+AND+(power+or+electricity+or+relay)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/hitlist.gif border=0 ALT=[HIT_LIST]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=640&f=S&l=50&d=PTXT&s1=((G06F.CPCL.+AND+(%22intrusion+prevention+system%22+OR+%22intrusion+detection+system%22))+AND+((power+OR+electricity)+OR+relay))&p=14&Query=CPCL/G06F+AND+(&quot;intrusion+prevention+system&quot;+OR+&quot;intrusion+detection+system&quot;)+AND+(power+or+electricity+or+relay)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/nextlist.gif border=0 ALT=[NEXT_LIST]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=639&f=G&l=50&d=PTXT&s1=((G06F.CPCL.+AND+(%22intrusion+prevention+system%22+OR+%22intrusion+detection+system%22))+AND+((power+OR+electricity)+OR+relay))&p=13&OS=CPCL/G06F+AND+(&quot;intrusion+prevention+system&quot;+OR+&quot;intrusion+detection+system&quot;)+AND+(power+or+electricity+or+relay)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/prevdoc.gif border=0 ALT=[PREV_DOC]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=641&f=G&l=50&d=PTXT&s1=((G06F.CPCL.+AND+(%22intrusion+prevention+system%22+OR+%22intrusion+detection+system%22))+AND+((power+OR+electricity)+OR+relay))&p=13&OS=CPCL/G06F+AND+(&quot;intrusion+prevention+system&quot;+OR+&quot;intrusion+detection+system&quot;)+AND+(power+or+electricity+or+relay)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/nextdoc.gif border=0 ALT=[NEXT_DOC]></A>

<A href="#bottom"><IMG src="/netaicon/PTO/bottom.gif" alt="[Bottom]" valign="middle" border="0"></A>
</TD></TR>
   <TR><TD align="center">
   <A href="https://certifiedcopycenter.uspto.gov/other/patft/view.html?backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D640%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3D((G06F.CPCL.%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522))%252BAND%252B((power%252BOR%252Belectricity)%252BOR%252Brelay))%26p%3D13%26OS%3DCPCL%2FG06F%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522)%252BAND%252B(power%252Bor%252Belectricity%252Bor%252Brelay)&backLabel1=Back%20to%20Document%3A%208925090"><IMG border="0" src="/netaicon/PTO/cart.gif" border="0" valign="middle" alt="[View Shopp
ing Cart]"></A>
   <A href="https://certifiedcopycenter.uspto.gov/other/patft/order.html?docNumber=8925090&backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D640%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3D((G06F.CPCL.%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522))%252BAND%252B((power%252BOR%252Belectricity)%252BOR%252Brelay))%26p%3D13%26OS%3DCPCL%2FG06F%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522)%252BAND%252B(power%252Bor%252Belectricity%252Bor%252Brelay)&backLabel1=Back%20to%20Document%3A%208925090">
   <IMG border="0" src="/netaicon/PTO/order.gif" valign="middle" alt="[Add to Shopping Cart]"></A>
   </TD></TR>
   <TR><TD align="center">
   <a href=http://pdfpiw.uspto.gov/.piw?Docid=08925090&homeurl=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO2%2526Sect2%3DHITOFF%2526u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%2526r%3D640%2526f%3DG%2526l%3D50%2526d%3DPTXT%2526s1%3D((G06F.CPCL.%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522))%252BAND%252B((power%252BOR%252Belectricity)%252BOR%252Brelay))%2526p%3D13%2526OS%3DCPCL%2FG06F%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522)%252BAND%252B(power%252Bor%252Belectricity%252Bor%252Brelay)%2526RS%3D((CPCL%2FG06F%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522))%252BAND%252B((power%252BOR%252Belectricity)%252BOR%252Brelay))&PageNum=&Rtype=&SectionNum=&idkey=NONE&Input=View+first+page><img src="/netaicon/PTO/image.gif" alt="[Image]" border="0" valign="middle"></A>

   </TD></TR>
</TABLE>
</CENTER>
<TABLE width="100%">
<TR><TD align="left" width="50%">&nbsp;</TD>
<TD align="right" valign="bottom" width="50%"><FONT size="-1">( <STRONG>640</STRONG></FONT> <FONT size=-2>of</FONT> <STRONG><FONT size=-1>1029</STRONG> )</FONT></TD></TR></TABLE>
<HR>
   <TABLE width="100%">
   <TR>	<TD align="left" width="50%"><b>United States Patent </b></TD>
   <TD align="right" width="50%"><b>8,925,090</b></TD>
   </TR>
     <TR><TD align="left" width="50%"><b>
         Kc
, &nbsp; et al.</b>
     </TD>
     <TD align="right" width="50%"> <b>
     December 30, 2014
</b></TD>
     </TR>
     </TABLE>
       <HR>
       <FONT size="+1">Methods, systems, and media for detecting and preventing malcode execution
</FONT><BR>
       <BR><CENTER><b>Abstract</b></CENTER>
       <p> A system for detecting and halting execution of malicious code includes a
     kernel-based system call interposition mechanism and a libc function
     interception mechanism. The kernel-based system call interposition
     mechanism detects a system call request from an application, determines a
     memory region from which the system call request emanates, and halts
     execution of the code responsible for the call request if the memory
     region from which the system call request emanates is a data memory
     region. The libc function interception mechanism maintains an alternative
     wrapper function for each of the relevant standard libc routines,
     intercepts a call from an application to one or more libc routines and
     redirects the call into the corresponding alternative wrapper function.
</p>
       <HR>
<TABLE width="100%"> <TR> <TH scope="row" valign="top" align="left" width="10%">Inventors:</TH> <TD align="left" width="90%">
 <B>Kc; Gaurav S.</B> (Mountain View, CA)<B>, Aho; Alfred V.</B> (Chatham, NJ) </TD> </TR>
<TR><TH scope="row" valign="top" align="left" width="10%">Applicant: </TH><TD align="left" width="90%"> <TABLE> <TR> <TH scope="column" align="center">Name</TH> <TH scope="column" align="center">City</TH> <TH scope="column" align="center">State</TH> <TH
scope="column" align="center">Country</TH> <TH scope="column" align="center">Type</TH> </TR> <TR> <TD> <b><BR>Kc; Gaurav S.
<BR>Aho; Alfred V.</b> </TD><TD> <BR>Mountain View
<BR>Chatham </TD><TD align="center"> <BR>CA
<BR>NJ </TD><TD align="center"> <BR>US
<BR>US </TD> </TD><TD align="left"> </TD> </TR> </TABLE>
<!-- AANM>
~AANM Kc; Gaurav S.
~AACI Mountain View
~AAST CA
~AACO US
~AANM Aho; Alfred V.
~AACI Chatham
~AAST NJ
~AACO US
</AANM -->
</TD></TR>
<TR> <TH scope="row" valign="top" align="left" width="10%">Assignee:</TH>
<TD align="left" width="90%">

<B>The Trustees of Columbia University in the City of New York</B>
 (New York, 
NY)
<BR>

</TD>
</TR>
       <TR><TH scope="row" valign="top" align="left" width="10%" nowrap>Family ID:
       </TD><TD align="left" width="90%">
       <b>44169552
</b></TD></TR>
       <TR><TH scope="row" valign="top" align="left" width="10%" nowrap>Appl. No.:
       </TH><TD align="left" width="90%">
       <b>13/152,627</b></TD></TR>
       <TR><TH scope="row" valign="top" align="left" width="10%">Filed:
       </TH><TD align="left" width="90%">
       <b>June 3, 2011</b></TD></TR>
     </TABLE>
<HR> <CENTER><b>Prior Publication Data</b></CENTER> <HR> <TABLE width="100%"> <TR><TH scope="col"></TH><TH scope="col"></TH><TD></TD></TR> <TR><TD align="left">
</TD><TH scope='col' align=center><B><U>Document Identifier</U></B></TH><TH scope='col' align=center><B><U>Publication Date</U></B></TH></TR><TR><TD align=center> </TD><TD align=center> US 20110289586 A1</TD><TD align=center>Nov 24, 2011</TD></TR><TR><TD align=center> 
</TD>
</TR> </TABLE>
<HR> <CENTER><b>Related U.S. Patent Documents</b></CENTER> <HR> <TABLE width="100%"> <TR><TH scope="col" width="7%"></TH><TH scope="col"></TH><TH scope="col"></TH> <TH scope="col"></TH><TH scope="col"></TH><TD></TD></TR> <TR><TD align="left">
</TD><TH scope='col' align=center><B><U>Application Number</U></B></TH><TH scope='col' align=center><B><U>Filing Date</U></B></TH><TH scope='col' align=center><B><U>Patent Number</U></B></TH><TH scope='col' align=center><B><U>Issue Date</U></B></TH><TD</TD></TR><TR><TD align=center> </TD><TD align=center>11181165</TD><TD align=center>Jul 14, 2005</TD><TD align=center>7971255</TD><TD align=center></TD><TD</TD></TR><TR><TD align=center> </TD><TD align=center>60588205</TD><TD align=center>Jul 15, 2004</TD><TD align=center></TD><TD align=center></TD><TD</TD></TR><TR><TD align=center> 
</TD>
</TR> </TABLE>     <HR>
<p> <TABLE width="100%"> <TR><TD valign="top" align="left" width="30%"><b>Current U.S. Class:</b></TD> <TD valign="top" align="right" width="70%"><b>726/24</b>; 726/2; 726/26 </TD></TR> 
       <TR><TD valign="top" align="left" width="30%"><b>Current CPC Class: </b></TD>
       <TD valign="top" align="right" width="70%">G06F 21/566&nbsp(20130101); G06F 12/1491&nbsp(20130101); G06F 2221/2101&nbsp(20130101); G06F 2221/2105&nbsp(20130101); G06F 21/00&nbsp(20130101); G06F 2221/2149&nbsp(20130101); H04L 63/1416&nbsp(20130101); H04L 63/1441&nbsp(20130101); G06F 2221/2141&nbsp(20130101)</TD></TR>
         <TR><TD valign="top" align="left" width="30%"><b>Current International Class: </b></TD>
         <TD valign="top" align="right" width="70%">G06F 21/00&nbsp(20130101)</TD></TR>
       <TR><TD valign="top" align="left" width="30%"><b>Field of Search: </b></TD>
       <TD align="right" valign="top" width="70%">
       






 ;726/24,22,23,25,26,27,2
       </TD></TR>
     </TABLE>
<HR><CENTER><b>References Cited  <A href="/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2Fsearch-adv.htm&r=0&f=S&l=50&d=PALL&Query=ref/8925090">[Referenced By]</A></b></CENTER>       <HR>
       <CENTER><b>U.S. Patent Documents</b></CENTER>
<TABLE width="100%"> <TR><TH scope="col" width="33%"></TH> <TH scope="col" width="33%"></TH> <TH scope="col" width="34%"></TH></TR> <TR> <TD align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F5257381">5257381</a></TD><TD align =left>
October 1993</TD><TD align=left>
Cook</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F5590329">5590329</a></TD><TD align =left>
December 1996</TD><TD align=left>
Goodnow et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F5634046">5634046</a></TD><TD align =left>
May 1997</TD><TD align=left>
Chatterjee et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F5899987">5899987</a></TD><TD align =left>
May 1999</TD><TD align=left>
Yarom</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F5956710">5956710</a></TD><TD align =left>
September 1999</TD><TD align=left>
Yarom</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6026235">6026235</a></TD><TD align =left>
February 2000</TD><TD align=left>
Shaughnessy</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6154877">6154877</a></TD><TD align =left>
November 2000</TD><TD align=left>
Ramkumar et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6161219">6161219</a></TD><TD align =left>
December 2000</TD><TD align=left>
Ramkumar et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6202176">6202176</a></TD><TD align =left>
March 2001</TD><TD align=left>
Baldischweiler et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6282703">6282703</a></TD><TD align =left>
August 2001</TD><TD align=left>
Meth et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6412071">6412071</a></TD><TD align =left>
June 2002</TD><TD align=left>
Hollander et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6529985">6529985</a></TD><TD align =left>
March 2003</TD><TD align=left>
Deianov et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6618736">6618736</a></TD><TD align =left>
September 2003</TD><TD align=left>
Menage</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6732211">6732211</a></TD><TD align =left>
May 2004</TD><TD align=left>
Goyal et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6735774">6735774</a></TD><TD align =left>
May 2004</TD><TD align=left>
Krishnaswamy</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6823460">6823460</a></TD><TD align =left>
November 2004</TD><TD align=left>
Hollander et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6832302">6832302</a></TD><TD align =left>
December 2004</TD><TD align=left>
Fetzer et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6868495">6868495</a></TD><TD align =left>
March 2005</TD><TD align=left>
Glover</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6907421">6907421</a></TD><TD align =left>
June 2005</TD><TD align=left>
Keshav et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6976258">6976258</a></TD><TD align =left>
December 2005</TD><TD align=left>
Goyal et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7010698">7010698</a></TD><TD align =left>
March 2006</TD><TD align=left>
Sheymov</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7039718">7039718</a></TD><TD align =left>
May 2006</TD><TD align=left>
Vertes</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7039919">7039919</a></TD><TD align =left>
May 2006</TD><TD align=left>
Hunt</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7162735">7162735</a></TD><TD align =left>
January 2007</TD><TD align=left>
Safa</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7191469">7191469</a></TD><TD align =left>
March 2007</TD><TD align=left>
Erlingsson</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7213153">7213153</a></TD><TD align =left>
May 2007</TD><TD align=left>
Hollander et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7219354">7219354</a></TD><TD align =left>
May 2007</TD><TD align=left>
Huang et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7225428">7225428</a></TD><TD align =left>
May 2007</TD><TD align=left>
Fetzer et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7228423">7228423</a></TD><TD align =left>
June 2007</TD><TD align=left>
Asai et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7228563">7228563</a></TD><TD align =left>
June 2007</TD><TD align=left>
Szor</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7266658">7266658</a></TD><TD align =left>
September 2007</TD><TD align=left>
Harrington et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7287281">7287281</a></TD><TD align =left>
October 2007</TD><TD align=left>
Szor</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7313824">7313824</a></TD><TD align =left>
December 2007</TD><TD align=left>
Bala et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7343421">7343421</a></TD><TD align =left>
March 2008</TD><TD align=left>
Goyal</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7380039">7380039</a></TD><TD align =left>
May 2008</TD><TD align=left>
Miloushev et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7392543">7392543</a></TD><TD align =left>
June 2008</TD><TD align=left>
Szor</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7415712">7415712</a></TD><TD align =left>
August 2008</TD><TD align=left>
Hunt</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7434210">7434210</a></TD><TD align =left>
October 2008</TD><TD align=left>
Tucker</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7437759">7437759</a></TD><TD align =left>
October 2008</TD><TD align=left>
Szor</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7493630">7493630</a></TD><TD align =left>
February 2009</TD><TD align=left>
Hunt</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7509639">7509639</a></TD><TD align =left>
March 2009</TD><TD align=left>
Worley, Jr.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7552203">7552203</a></TD><TD align =left>
June 2009</TD><TD align=left>
Giles et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7555777">7555777</a></TD><TD align =left>
June 2009</TD><TD align=left>
Swimmer et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7594111">7594111</a></TD><TD align =left>
September 2009</TD><TD align=left>
Kiriansky et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7596694">7596694</a></TD><TD align =left>
September 2009</TD><TD align=left>
Karp et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7603704">7603704</a></TD><TD align =left>
October 2009</TD><TD align=left>
Bruening et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7739401">7739401</a></TD><TD align =left>
June 2010</TD><TD align=left>
Goyal</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7849311">7849311</a></TD><TD align =left>
December 2010</TD><TD align=left>
Donlin et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7886148">7886148</a></TD><TD align =left>
February 2011</TD><TD align=left>
Kiriansky et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7971255">7971255</a></TD><TD align =left>
June 2011</TD><TD align=left>
Kc et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F8011006">8011006</a></TD><TD align =left>
August 2011</TD><TD align=left>
Suzuki et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F8042179">8042179</a></TD><TD align =left>
October 2011</TD><TD align=left>
Shoji et al.</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20020013907&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2002/0013907</a></TD><TD align =left>
January 2002</TD><TD align=left>
May</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20020072830&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2002/0072830</a></TD><TD align =left>
June 2002</TD><TD align=left>
Hunt</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20030005168&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2003/0005168</a></TD><TD align =left>
January 2003</TD><TD align=left>
Leerssen et al.</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20030014667&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2003/0014667</a></TD><TD align =left>
January 2003</TD><TD align=left>
Kolichtchak</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20030018832&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2003/0018832</a></TD><TD align =left>
January 2003</TD><TD align=left>
Amirisetty et al.</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20030177474&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2003/0177474</a></TD><TD align =left>
September 2003</TD><TD align=left>
de Jong et al.</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20030212766&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2003/0212766</a></TD><TD align =left>
November 2003</TD><TD align=left>
Giles et al.</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20030233385&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2003/0233385</a></TD><TD align =left>
December 2003</TD><TD align=left>
Srinivasa et al.</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20040133777&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2004/0133777</a></TD><TD align =left>
July 2004</TD><TD align=left>
Kiriansky et al.</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20040153709&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2004/0153709</a></TD><TD align =left>
August 2004</TD><TD align=left>
Burton-Krahn</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20040158729&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2004/0158729</a></TD><TD align =left>
August 2004</TD><TD align=left>
Szor</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20040168078&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2004/0168078</a></TD><TD align =left>
August 2004</TD><TD align=left>
Brodley et al.</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20040177244&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2004/0177244</a></TD><TD align =left>
September 2004</TD><TD align=left>
Murphy et al.</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20040177245&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2004/0177245</a></TD><TD align =left>
September 2004</TD><TD align=left>
Murphy</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20040268361&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2004/0268361</a></TD><TD align =left>
December 2004</TD><TD align=left>
Schaefer</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20050005101&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2005/0005101</a></TD><TD align =left>
January 2005</TD><TD align=left>
Yenduri</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20050010804&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2005/0010804</a></TD><TD align =left>
January 2005</TD><TD align=left>
Bruening et al.</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20050091310&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2005/0091310</a></TD><TD align =left>
April 2005</TD><TD align=left>
Salomon</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20050108562&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2005/0108562</a></TD><TD align =left>
May 2005</TD><TD align=left>
Khazan et al.</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20050132031&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2005/0132031</a></TD><TD align =left>
June 2005</TD><TD align=left>
Sailer et al.</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20050273600&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2005/0273600</a></TD><TD align =left>
December 2005</TD><TD align=left>
Seeman</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20050273858&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2005/0273858</a></TD><TD align =left>
December 2005</TD><TD align=left>
Zadok et al.</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20060206899&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2006/0206899</a></TD><TD align =left>
September 2006</TD><TD align=left>
Suzuki et al.</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20070055711&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2007/0055711</a></TD><TD align =left>
March 2007</TD><TD align=left>
Polyakov et al.</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20070204261&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2007/0204261</a></TD><TD align =left>
August 2007</TD><TD align=left>
Fetzer et al.</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20080155702&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2008/0155702</a></TD><TD align =left>
June 2008</TD><TD align=left>
Bala et al.</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20090049193&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2009/0049193</a></TD><TD align =left>
February 2009</TD><TD align=left>
Goyal</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20110289586&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2011/0289586</a></TD><TD align =left>
November 2011</TD><TD align=left>
Kc et al.</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20120324167&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2012/0324167</a></TD><TD align =left>
December 2012</TD><TD align=left>
Yokosawa</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20140082327&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2014/0082327</a></TD><TD align =left>
March 2014</TD><TD align=left>
Ghose</TD></TR><TR><TD align=left>
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20140082329&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2014/0082329</a></TD><TD align =left>
March 2014</TD><TD align=left>
Ghose</TD></TR><TR><TD align=left>

</TD>
</TR> </TABLE>
<TABLE width="90%"> <BR> <CENTER><b>Other References</b></CENTER> <TR><TD><align="left"><BR>Acharya, A. and Raje, M., "MAPbox: Using Parameterized Behavior Classes to Confine Applications", In Proceedings of the 9th USENIX Security Symposium (SSYM
'00), Denver, CO, USA, Aug. 14-17, 2000. cited by applicant
.<BR>Aleph One, "Smashing the Stack for Fun and Profit", In Phrack, vol. 7, No. 49, Nov. 1996. cited by applicant
.<BR>Alexandrov, A., et al., "Consh: A Confined Execution Environment for Internet Computations", Technical Report, Dec. 7, 1998. cited by applicant
.<BR>Balzer, R.M. and Goldman, N.M., "Mediating Connectors: A Non-Bypassable Process Wrapping Technology", In Proceedings of the DARPA Information Survivability Conference and Exposition (DISCEX '00), vol. 2, Hilton Head, SC, USA, Jan. 25-27, 2000, pp.
361-368. cited by applicant
.<BR>Baratloo, A., et al., "Transparent Run-Time Defense Against Stack Smashing Attacks", In Proceedings of the 2000 USENIX Annual Technical Conference (ATEC '00), San Diego, CA, USA, Jun. 18-23, 2000, pp. 251-262. cited by applicant
.<BR>Barrantes, E.G., et al., "Randomized Instruction Set Emulation to Disrupt Binary Code Injection Attacks", In Proceedings of the 10th ACM Conference on Computer and Communications Security (CCS '03) Conference, Washington, DC, USA, Oct. 27-31, 2003,
pp. 282-289. cited by applicant
.<BR>Berman, A., et al., "TRON: Process-Specific File Protection for the UNIX Operating System", In Proceedings of 1995 USENIX Winter Technical Conference (TCON '95), New Orleans, LA, USA, Jan. 16-20, 1995, pp. 165-175. cited by applicant
.<BR>Bhatkar, S., "Address Obfuscation: An Efficient Approach to Combat a Broad Range of Memory Error Exploits", In Proceedings of the 12th USENIX Security Symposium (SSYM '03), Washington, DC, USA, Aug. 4-8, 2003, pp. 105-120. cited by applicant
.<BR>Bulba and Kil3r, "Bypassing StackGuard and StackShield", In Phrack, No. 56, May 2000. cited by applicant
.<BR>CERT, "CERT Advisory CA-2001-19: `Code Red` Worm Exploiting Buffer Overflow in IIS Indexing Service DLL", Jul. 19, 2001, available at: http://www.cert.org/advisories/CA-2001-19.html. cited by applicant
.<BR>CERT, "CERT Advisory CA-2001-26: Nimda Worm", Sep. 18, 2001, available at: http://www.cert.org/advisories/CA-2001-26.html. cited by applicant
.<BR>CERT, "CERT Advisory CA-2001-33: Multiple Vulnerabilities in WU-FTPD", Feb. 15, 2002, available at: http://www.cert.org/advisories/CA-2001-33.html. cited by applicant
.<BR>CERT, "CERT Advisory CA-2002-12: Format String Vulnerability in ISC DHCPD", Oct. 7, 2002, available at: http://www.cert.org/advisories/CA-2002-12.html. cited by applicant
.<BR>CERT, "CERT Advisory CA-2003-25, Buffer Overflow in Sendmail", Sep. 29, 2003, available at: http://www.cert.org/advisories/CA-2003-25.html. cited by applicant
.<BR>CERT, "CERT Advisory CA-2003-28: Buffer Overflow in Windows Workstation Service", Nov. 20, 2003, available at: http://www.cert.org/advisories/CA-2003-28.html. cited by applicant
.<BR>Chari, S.N. and Cheng, P.C., "BlueBoX: A Policy-driven, Host-Based <A Name=h1 HREF=#h0></A><A  HREF=#h2></A><B><I>Intrusion Detection System</I></B>", In Proceedings of the 9th Symposium on Network and Distributed Systems Security (NDSS '02), San Diego, CA, USA, Feb. 6-8, 2002. cited by applicant
.<BR>Chen, H., et al., "Model Checking One Million Lines of C Code", In Proceedings of the 11th Network and Distributed System Security Symposium (NDSS '04), Feb. 5-6, 2004, pp. 171-185. cited by applicant
.<BR>Chen, H., et al., "MOPS: An Infrastructure for Examining Security Properties of Software", In Proceedings of the 9th ACM Conference on Computer and Communications Security (CCS 2002), Washington, DC, USA, Nov. 18-22, 2002, pp. 235-244. cited by
applicant
.<BR>Chew, M. and Song, D., "Mitigating Buffer Overflows by Operating System Randomization", Technical Report, Computer Science Technical Report 65, Carnegie Mellon University, Dec. 2002. cited by applicant
.<BR>Christodorescu, M. and Jha, S., "Static Analysis of Executables to Detect Malicious Patterns", In Proceedings of the 12th USENIX Security Symposium (SSYM '03), Washington, DC, USA, Aug. 4-8, 2003, pp. 169-186. cited by applicant
.<BR>Conover, M., "w00w00 on Heap Overflows", Jan. 1999, Technical Report, available at: http://www.w00w00.org/files/articles/heaptut.txt. cited by applicant
.<BR>Cowan, C., et al., "FormatGuard: Automatic Protection From printf Format String Vulnerabilites", In Proceedings of the 10th USENIX Security Symposium (SSYM '01), Washington, DC, USA, Aug. 13-17, 2001, pp. 191-199. cited by applicant
.<BR>Cowan, C., et al., "PointGuard: Protecting Pointers From Buffer Overflow Vulnerabilities", In Proceedings of the 12th USENIX Security Symposium (SSYM '03), Washington, DC, USA, Aug. 4-8, 2003, pp. 91-104. cited by applicant
.<BR>Cowan, C., et al., "Stackguard: Automatic Adaptive Detection and Prevention of Buffer-Overflow Attacks", In Proceedings of the 7th USENIX Security Symposium (SSYM '98), San Antonio, TX, USA, Jan. 26-29, 1998, pp. 63-78. cited by applicant
.<BR>Cowan, C., et al., "SubDomain: Parsimonious Server Security", In Proceedings of the 14th USENIX System Administration Conference (LISA 2000), New Orleans, LA, USA, Dec. 3-8, 2000, pp. 341-354. cited by applicant
.<BR>Durden, T., "Bypassing PaX ASLR Protection", In Phrack, No. 59, Jul. 2002. cited by applicant
.<BR>Engler, D. and Ashcraft, K., "RacerX: Effective, Static Detection of Race Conditions and Deadlocks", In Proceedings of the ACM Symposium on Operating Systems Principles (SOSP 2003), Bolton Landing, NY, USA, Oct. 19-22, 2003. cited by applicant
.<BR>Etoh, J., "GCC Extension for Protecting Applications From Stack-Smashing Attacks", IBM Research, Aug. 22, 2005, available at: http://www.trl.ibm.com/projects/security/ssp. cited by applicant
.<BR>Fayolle, P. and Glaume, V., "A Buffer Overflow Study: Attacks & Defenses", Technical Report, ENSEIRB Networks and Distributed Systems, Mar. 2002. cited by applicant
.<BR>Feng, H.H., et al., "Anomaly Detection Using Call Stack Information", In Proceedings of the IEEE Symposium on Security and Privacy (S&P '03), Oakland, CA, USA, May 11-14, 2003, pp. 62-77. cited by applicant
.<BR>Foster, J.S., et al., "A Theory of Type Qualifiers", In Proceedings of the ACMSIGPLAN Conference on Programming Language Design and Implementation (PLDI 1999), Atlanta, GA, USA, May 1-4, 1999. cited by applicant
.<BR>Frantzen, M. and Shuey, M., "StackGhost: Hardware Facilitated Stack Protection", In Proceedings of the 10th USENIX Security Symposium (SSYM '01), Washington, DC, USA, Aug. 13-17, 2001, pp. 55-66. cited by applicant
.<BR>Fraser, T., et al., "Hardening COTS Software with Generic Software Wrappers", In Proceedings of the IEEE Symposium on Security and Privacy (S&P '99), Oakland, CA, USA, May 9-12, 1999, pp. 2-16. cited by applicant
.<BR>Ganapathy, V., et al., "Buffer Overrun Detection Using Linear Programming and Static Analysis", In Proceedings of the 10th ACM Conference on Computer and Communications Security (CCS '03), Washington, DC, USA, Oct. 27-30, 2003, pp. 345-364. cited by
applicant
.<BR>Garfinkel, T. and Rosenblum, M., "A Virtual Machine Introspection Based Architecture for Intrusion Detection", In Proceedings of the 10th Network and Distributed System Security Symposium (NDSS '03), San Diego, CA, USA, Feb. 6-7, 2003, pp. 191-206.
cited by applicant
.<BR>Garfinkel, T., "Traps and Pitfalls: Practical Problems in System Call Interposition Based Security Tools", In Proceedings of the Network and Distributed Systems Security Symposium (NDSS '03), San Diego, CA, USA, Feb. 6-7, 2003, pp. 163-176. cited by
applicant
.<BR>Garfinkel, T., et al., "Ostia: A Delegating Architecture for Secure System Call Interposition", In Proceedings of the 11th Network and Distributed System Security Symposium (NDSS '04), San Diego, CA, USA, Feb. 5-6, 2004, pp. 187-201. cited by
applicant
.<BR>Gera and Riq, "Advances in Format String Exploitation", In Phrack, No. 59, Jul. 2002. cited by applicant
.<BR>Ghormley, D.P., et al., "SLIC: An Extensibility System for Commodity Operating Systems", In Proceedings of the USENIX Annual Technical Conference (ATEC '98), New Orleans, LA, USA, Jun. 15-19, 1998, pp. 39-52. cited by applicant
.<BR>Ghosh, A.K. and O'Connor, T., "Analyzing Programs for Vulnerability to Buffer Overrun Attacks", In Proceedings of the 21st National Information Systems Security Conference (21st NISSC), Crystal City, VA, USA, Oct. 6-9, 1998, pp. 274-382. cited by
applicant
.<BR>Giffin, J., et al., "Efficient Context-Sensitive Intrusion Detection", In Proceedings of the 11th Network and Distributed System Security Symposium (NDSS '04), San Diego, CA, USA, Feb. 5-6, 2004. cited by applicant
.<BR>Goldberg, I., et al., "A Secure Environment for Untrusted Helper Applications (Confining the Wily Hacker)", In Proceedings of the Sixth USENIX Security Symposium (SSYM '96), San Jose, CA, USA, Jul. 22-25, 1996. cited by applicant
.<BR>Haugh, E. and Bishop, M., "Testing C Programs for Buffer Overflow Vulnerabilities", In Proceedings of the 9th Network and Distributed System Security Symposium (NDSS '03), San Diego, CA, USA, Feb. 6-7, 2003. cited by applicant
.<BR>Hofmeyr, S.A., et. al., "<A Name=h2 HREF=#h1></A><A  HREF=#h3></A><B><I>Intrusion Detection System</I></B> Using Sequences of System Calls", In Journal of Computer Security, vol. 6, No. 3, Aug. 18, 1998, pp. 151-180. cited by applicant
.<BR>Jim, T., et al., "Cyclone: A Safe Dialect of C", In Proceedings of the USENIX Annual Technical Conference (ATEC '02), Monterey, CA, USA, Jun. 10-15, 2002, pp. 275-288. cited by applicant
.<BR>Johnson, S.C., "Lint, a C Program Checker", Technical Report, Bell Laboratories Computer Science Technical Report 65, Jul. 26, 1978. cited by applicant
.<BR>Jones, R.W.M. and Kelly, P.H.J., "Backwards-Compatible Bounds Checking for Arrays and Pointers in C Programs", In Proceedings of the Third International Workshop on Automated Debugging, Linkoping, SE, May 26-28, 1997, pp. 13-26. cited by applicant
.<BR>Kc, G.S. and Keromytis, A.D., "e-NeXSh: Achieving an Effectively Non-Executable Stack and Heap via System-Call Policing", In Proceedings of the 21st Annual Computer Security Applications Conference, Tucson, AZ, USA, Dec. 5-9, 2005, pp. 286-302.
cited by applicant
.<BR>Kc, G.S., et al., "Countering Code-Injection Attacks With Instruction-Set Randomization", In Proceedings of the ACM Computer and Communications Security (CCS '03) Conference, Washington, DC, USA, Oct. 27-30, 2003, pp. 272-280. cited by applicant
.<BR>Kiriansky, V., et al., "Secure Execution Via Program Shepherding", In Proceedings of the 11th USENIX Security Symposium (SSYM '02), San Francisco, CA, USA, Aug. 5-9, 2002, pp. 191-205. cited by applicant
.<BR>Klog, "The Frame Pointer Overwrite", In Phrack, No. 55, Sep. 1999. cited by applicant
.<BR>Ko, C., et al., "Detecting and Countering System Intrusions Using Software Wrappers", In Proceedings of the 9th USENIX Security Symposium (SSYM '00), Denver, CO, USA, Aug. 14-17, 2000, pp. 145-156. cited by applicant
.<BR>LaRochelle, D. and Evans, D., "Statically Detecting Likely Buffer Overflow Vulnerabilites", In Proceedings of the 10th USENIX Security Symposium (SSYM '01), Washington, DC, USA, Aug. 13-17, 2001, pp. 177-190. cited by applicant
.<BR>Lee, W., et al., "Learning Patterns from Unix Process Execution Traces for Intrusion Detection", In Proceedings of the AAAI97 Workshop on AI Methods in Fraud and Risk Management, Providence, RI, USA, Jul. 27, 1997, pp. 50-56. cited by applicant
.<BR>Lhee, K. and Chapin, S.J., "Type-Assisted Dynamic Buffer Overflow Detection", In Proceedings of the 11th USENIX Security Symposium (SSYM '02), San Francisco, CA, USA, Aug. 5-9, 2002, pp. 81-90. cited by applicant
.<BR>Loscocco, P. and Smalley, S., "Integrating Flexible Support for Security Policies into the Linux Operating System", In Proceedings of the FREENIX Track: 2001 USENIX Annual Technical Conference, Boston, MA, USA, Jun. 25-30, 2001, pp. 29-40. cited by
applicant
.<BR>Mitchem, T., et al., "Using Kernel Hypervisors to Secure Applications", In Proceedings of the 13th Annual Computer Security Applications Conference, San Diego, CA, USA, Dec. 8-12, 1997, pp. 175-181. cited by applicant
.<BR>Necula, G.C., et al., "CCured: Type-Safe Retrofitting of Legacy Code", In Proceedings of the Principles of Programming Language (PoPL '02), Portland, OR, USA, Jan. 16-18, 2002, pp. 128-139. cited by applicant
.<BR>Nergal, "The Advanced Return-Into-Lib(c) Exploits", In Phrack, No. 58, Dec. 2001. cited by applicant
.<BR>Office Action dated Dec. 4, 2009 in U.S. Appl. No. 11/181,165. cited by applicant
.<BR>Office Action dated Feb. 4, 2009 in U.S. Appl. No. 11/181,165. cited by applicant
.<BR>Office Action dated Jun. 30, 2010 in U.S. Appl. No. 11/181,165. cited by applicant
.<BR>Peterson, D.S., et al., "A Flexible Containment Mechanism for Executing Untrusted Code", In Proceedings of the 11th USENIX Security Symposium (SSYM '02), San Francisco, CA, USA, Aug. 5-9, 2002, pp. 207-225. cited by applicant
.<BR>Prasad, M. and Chiueh, T., "A Binary Rewriting Defense Against Stack Based Buffer Overflow Attacks", In Proceedings of the USENIX Annual Technical Conference (ATEC D3), Boston, MA, USA, Jun. 9-14, 2003, pp. 211-224. cited by applicant
.<BR>Prevelakis, V. and Spinellis, D., "Sandboxing Applications", In Proceedings of the USENIX Annual Technical Conference (ATEC '01), Boston, MA, USA, Jun. 25-30, 2001, pp. 119-126. cited by applicant
.<BR>Provos, N., "Improving Host Security with System Call Policies", In Proceedings of the 12th USENIX Security Symposium (SSYM '03), Washington, DC, USA, Aug. 4-8, 2003, pp. 257-272. cited by applicant
.<BR>Rabek, J.C., et al., "Detection of Injected, Dynamically Generated and Obfuscated Malicious Code", In Proceedings of the Workshop on Rapid Malcode (WORM 2003), Washington, DC, USA, Oct. 27, 2003, pp. 76-82. cited by applicant
.<BR>Rajagopalam, M., et al., "Cassyopia: Compiler Assisted System Optimization", In Proceedings of the 9th Workshop on Hot Topics in Operating Systems (HotOS IX), Lihue, HI, May 18-21, 2003, pp. 103-108. cited by applicant
.<BR>Richarte, G., "Four Different Tricks to Bypass StackShield and StackGuard Protection", Technical Report, Core Security Technologies, Apr. 9-Jun. 3, 2002. cited by applicant
.<BR>Rix, "Smashing C++ vptrs", In Phrack, No. 56, May 1, 2000. cited by applicant
.<BR>Ruwase, O. and Lam, M.S., "A Practical Dynamic Buffer Overflow Detector", In Proceedings of the 11th Network and Distributed System Security Symposium (NDSS '04), San Diego, CA, USA, Feb. 5-6, 2004, pp. 159-169. cited by applicant
.<BR>Shankar, U., et al., "Detecting Format String Vulnerabilites with Type Qualifiers", In Proceedings of the 10th USENIX Security Symposium (SSYM '01), Washington, DC, USA, Aug. 13-17, 2001, pp. 201-216. cited by applicant
.<BR>Solar Designer, "Getting Around Non-Executable Stack (and Fix)", Aug. 10, 1997, available at: http://seclists.org/bugtraq/1997/Aug/63. cited by applicant
.<BR>Spafford, E.H., "The Internet Worm Program: An Analysis", Technical Report, Purdue University Technical Report CSD-TR-823, Dec. 8, 1988. cited by applicant
.<BR>Tool Interface Standards Committee, "Executable and Linking Format (ELF) Specification", May 1995. cited by applicant
.<BR>U.S. Appl. No. 11/181,165, filed Jul. 14, 2005. cited by applicant
.<BR>Van de Ven, A., "New Security Enhancements in Red Hat Enterprise Linux v.3, Update 3", Technical Report, Redhat, Aug. 2004, pp. 1-10. cited by applicant
.<BR>Vendicator, "Stack Shield: A `Stack Smashing` Technique Protection Tool for Linux", Jan. 7, 2000, available at: http://angelfire.com/sk/stackshield. cited by applicant
.<BR>Wagner, D. and Dean, D., "Intrusion Detection via Static Analysis", In Proceedings of the IEEE Symposium on Security and Privacy (S&P '99), Oakland, CA, USA, May 14-16, 2001, pp. 156-168. cited by applicant
.<BR>Wagner, D., et al., "A First Step Towards Automated Detection of Buffer Overrun Vulnerabilities", In Proceedings of the 7th Network and Distributed System Security Symposium (NDSS 2000), San Diego, CA, USA, Feb. 3-4, 2000, pp. 3-17. cited by
applicant
.<BR>Walker, K.M., et al., "Confining Root Programs with Domain and Type Enforcement (DTE)", In Proceedings of the 6th USENIX Security Symposium (SSYM '96), San Jose, CA, USA, Jul. 22-25, 1996, pp. 21-36. cited by applicant
.<BR>Warrender, C., et al., "Detecting Intrusions Using System Calls: Alternative Data Models", In IEEE Symposium on Security and Privacy (S&P '99), Oakland, CA, USA, May 9-12, 1999, pp. 133-145. cited by applicant
.<BR>Watson, R.N.M., "TrustedBSD: Adding Trusted Operating System Features to FreeBSD", In Proceedings of the USENIX Annual Technical Conference (ATEC '01), Boston, MA, USA, Jun. 25-30, 2001, pp. 15-28. cited by applicant
.<BR>Wespi, A., et al., "Intrusion Detection Using Variable-Length Audit Trail Patterns", In Proceedings of the 3rd International Workshop on the Recent Advances in Intrusion Detection (RAID 2000), Toulouse, FR, Oct. 2-4, 2000, pp. 110-129. cited by
applicant
.<BR>Wilander, J. and Kamkar, M., "A Comparison of Publicly Available Tools for Dynamic Buffer Overflow Prevention", In Proceedings of the 10th Network and Distributed System Security Symposium (NDSS '03), San Diego, CA, USA, Feb. 6-7, 2003. cited by
applicant
.<BR>Xie, Y., et al., "Archer: Using Symbolic, Path-Sensitive Analysis to Detect Memory Access Errors", In Proceedings of the 9th European Software Engineering Conference and the 11th ACM Symposium on the Foundations of Software Engineering (ESED/FSE
2003), Helsinki, FI, Sep. 1-5, 2003, pp. 277-286. cited by applicant
.<BR>Yang, J., et al., "MECA: an Extensible, Expressive System and Language for Statically Checking Security Properties", In Proceedings of the 10th ACM Conference on Computer and Communications Security (CCS D3), Washington, DC, USA, Oct. 27-31, 2003,
pp. 321-334. cited by applicant. </TD></TR> </TABLE> <BR>
       <i>Primary Examiner:</i> Cervetti; David Garcia
<BR>
       <i>Attorney, Agent or Firm:</i> <coma>Byrne Poh LLP
<BR>
       <HR>
       <CENTER><b><i>Parent Case Text</b></i></CENTER>
       <HR>
       <BR><BR>CROSS REFERENCE TO RELATED APPLICATIONS
<BR><BR> This application is a continuation of U.S. patent application Ser. No.
     11/181,165, filed Jul. 14, 2005, now U.S. Pat. No. 7,971,255, which
     claims the benefit of U.S. Provisional Patent Application No. 60/588,205,
     filed Jul. 15, 2004, which are hereby incorporated by reference herein in
     their entireties.
         <HR>
<CENTER><b><i>Claims</b></i></CENTER> <HR> <BR><BR>What is claimed is: <BR><BR> 1.  A method for detecting and halting execution of malicious code, the method comprising: creating a plurality of wrapper functions that each correspond to one of a
plurality of library functions in an application;  intercepting a system call request from the application to a library function;  redirecting the system call request to a wrapper function from the plurality of created wrapper functions that corresponds
to the library function;  using the wrapper function to determine a memory region from which the system call request emanates, wherein the wrapper function determines whether return addresses associated with one or more intermediate functions in the
system call request emanate from a write protected memory region;  and executing the system call request based at least in part on the determined memory region.
<BR><BR> 2.  The method of claim 1, wherein the plurality of wrapper functions are interposed between the application and the plurality of library functions.
<BR><BR> 3.  The method of claim 1, wherein the wrapper function verifies a preceding instruction in the write protected memory region.
<BR><BR> 4.  The method of claim 1, further comprising communicating with an operating system kernel to request interaction with one or more resources.
<BR><BR> 5.  The method of claim 1, further comprising providing an indication that signals presence of the malicious code based at least in part on the verification.
<BR><BR> 6.  The method of claim 1, wherein a stack walk is performed along a dynamic chain of each wrapper function that validates call site memory addresses and target site memory addresses against start limits and end limits for the library function
associated with the wrapper function.
<BR><BR> 7.  The method of claim 6, wherein an innermost caller-callee pair in the dynamic chain is a direct call function.
<BR><BR> 8.  The method of claim 1, further comprising reporting information about the malicious code upon detection of the malicious code.
<BR><BR> 9.  A system for detecting and halting execution of malicious code, the system comprising: a processor that: creates a plurality of wrapper functions that each correspond to one of a plurality of library functions in an application;  intercepts
a system call request from the application to a library function;  redirects the system call request to a wrapper function from the plurality of created wrapper functions that corresponds to the library function;  uses the wrapper function to determine a
memory region from which the system call request emanates, wherein the wrapper function determines whether return addresses associated with one or more intermediate functions in the system call request emanate from a write protected memory region;  and
executes the system call request based at least in part on the determined memory region.
<BR><BR> 10.  The system of claim 9, wherein the plurality of wrapper functions are interposed between the application and the plurality of library functions.
<BR><BR> 11.  The system of claim 9, wherein the processor is further configured to use the wrapper function to verify a preceding instruction in the write protected memory region.
<BR><BR> 12.  The system of claim 9, wherein the processor is further configured to communicate with an operating system kernel to request interaction with one or more resources.
<BR><BR> 13.  The system of claim 9, wherein the processor is further configured to provide an indication that signals presence of the malicious code based at least in part on the verification.
<BR><BR> 14.  The system of claim 9, wherein the processor is further configured to perform a stack walk along a dynamic chain of each wrapper function that validates call site memory addresses and target site memory addresses against start limits and
end limits for the library function associated with the wrapper function.
<BR><BR> 15.  The system of claim 14, wherein an innermost caller-callee pair in the dynamic chain is a direct call function.
<BR><BR> 16.  The system of claim 9, wherein the processor is further configured to report information about the malicious code upon detection of the malicious code.
<BR><BR> 17.  A non-transitory computer-readable medium containing computer-executable instructions that, when executed by a processor, cause the processor to perform a method for detecting and halting execution of malicious code, the method comprising:
creating a plurality of wrapper functions that each correspond to one of a plurality of library functions in an application;  intercepting a system call request from the application to a library function;  redirecting the system call request to a wrapper
function from the plurality of created wrapper functions that corresponds to the library function;  using the wrapper function to determine a memory region from which the system call request emanates, wherein the wrapper function determines whether
return addresses associated with one or more intermediate functions in the system call request emanate from a write protected memory region;  and executing the system call request based at least in part on the determined memory region. <HR>
<CENTER><b><i>Description</b></i></CENTER> <HR> <BR><BR>BACKGROUND OF THE INVENTION
<BR><BR> The present invention relates to computer systems, and more particularly, to techniques for detecting and preventing malicious code execution within a computer system.
<BR><BR> There is no way to completely categorize all forms of attacks on software systems, but the most common attack techniques can be considered as either (1) application-level attacks employed by Internet crackers and worms, and (2) denial-of-service
attacks and attacks that exploit `logic errors" in the software to cause race conditions or otherwise change the execution of the program.
<BR><BR> The first category, application level attacks, exploit vulnerabilities in the software, and force the system to run code of the attackers' choice.  This form of attack is the focus of the embodiments described herein.  The attacks within the
second category require different defense methods, which are outside the scope of the embodiments described herein.
<BR><BR> Launching a successful attack that exploits security flaws in software with the intent of compromising the running software has typically involved (a) the attacker overriding the flow of control in the program's execution, and redirecting
control to malicious code, i.e., code of the attacker's choice, and (b) introducing malicious code into the program memory.
<BR><BR> Control Overriding
<BR><BR> Application level attacks generally involve buffer overruns or format-string exploits to overwrite crucial locations in the program memory that contain "code pointers." These code pointers include the return-address and the old-frame-pointer
values stored in activation records on the program stack, function-pointer variables, and entries in the procedure-linkage (PLT), global-offset (GOT) and virtual function-pointer (VPTR) tables in the heap, .bss (un-initialized static area) and the
initialized static data areas.  What is special about these code pointers is that the control flow of the program is directly affected by the values stored in these locations, e.g., the return-address value determines what code is executed after a
function has completed execution and needs to return control to its caller.  Attackers exploiting buffer-overrun and format-string vulnerabilities try to write the address of "malicious code" into these memory locations, with the aim of getting the
processor to start fetching and executing instructions from the malicious code at some point.
<BR><BR> The chief factor that enables a malicious attacker to exploit software flaws to force a control override in the program execution is the low-level, data-handling <B><I>power</I></B> afforded by systems languages like C and C++.  Specifically, the lack of
bounds checking on pointer arithmetic (array indexing is implemented as pointer operations) for these languages permits write operations to virtually any part of data memory.  Consequently, poor programming practices can lead to a failure on the part of
application developers to explicitly validate the size and/or format of the input data.  This results in buffer overflows, where input data is copied past the end of the memory space reserved for the data copy, and onto adjoining data.  Unfortunately, it
is not just application code that is likely to suffer from such vulnerabilities--core routines in the C standard library (libc) such as printf, gets, syslog, and strcpy cannot make assumptions about the size of input and/or output data, and hence are
implemented to blindly copy data from the memory location depicted by the input parameter until this data is exhausted.  Such buffer overflows can cause severe memory corruption and possibly distort the execution of the program.  It is not surprising
that buffer overflows are perhaps the most widely exploited type of vulnerability, accounting for approximately half the CERT/CC Advisories in recent years (see, www.cert.org/advisories/).
<BR><BR> Malicious Code
<BR><BR> A large class of successful attacks on software systems involves some form of injection of executable code via data I/O channels.  Once the malicious code is resident in the program memory, all the attacker needs to do is to trigger the injected
code via one of the mechanisms for overriding the control flow of the program, described in the last section.  However, given the advent of defense techniques that are capable of detecting code executing in memory normally reserved for data, attackers
have sought to redirect program control not just to injected code, but rather to existing routines such as system and execve in the standard library.  Such "return-into-libc" attacks avoid the need to both inject executable content into data areas of the
program memory and override the program flow of control.  There is, although, more work involved with these attacks since they need to "massage" the input parameters to these routines in order to make the effect of invoking these routines truly
malicious.
<BR><BR> It should be noted that injected code and certain functions in the standard library are not the only forms of code that can be abused by return-into-libc-style attacks--any program function can serve the attacker's purposes if (a) he has the
liberty of specifying its input parameters, and (b) it ultimately invokes some critical library functions or system-call routines.  The following illustrates a wrapper function that introduces vulnerabilities in this manner:
<BR><BR> TABLE-US-00001 1.  void execute(char *program) { 2.  / this is my own wrapper to system */ 3.  system(program); 4.  }
<BR><BR> Such programmer-created vulnerabilities may not necessarily be the result of bad programming practices, but could possibly be intentionally inserted by a disgruntled employee or other malicious insider who has access to the codebase.
<BR><BR> The following techniques make up the majority of attacks on software systems today.
<BR><BR> Stacksmashing Attack--In a demonstration of the classic "stacksmashing" attack technique, Aleph One ["Smashing the stack for fun and profit," Phrack, 7(49), 1996] provides a detailed walkthrough of how to exploit a stack buffer-overflow
vulnerability to inject attack code, and also overwrite the return address of the function to point to the starting address of this injected code.  This paper also suggests ways to increase the chances of the stacksmashing attack: pad the beginning of
the injected code with no-op instructions to make the exploit work even when the exact address of the injected code is not known, and approximate the actual position of the return address relative to that of the vulnerable buffer by copying the address
of the injected code over a range of locations, hopefully including the return address position
<BR><BR> The following illustrates a modified version of the original stack-smashing attack described by Aleph One, where malicious code is injected onto a stack buffer, and the buffer is overrun to overwrite the return address of the function, causing
an override of the control flow of the program.
<BR><BR> TABLE-US-00002 1 char *shellcode = 2 "\xeb\xif\x5e\x89\x76\x08\x31\xc0" 3 "\x88\x46\x07\x89\x46\x08\x0c\xb0" 4 "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c" 5 "\xcd\x80\x31\xdb\x89\xd8\x40\xcd" 6 "\x80\xe8\xdc\xff\xff\xff\bin\sh" 7 8 int main(void) { 9
char buffer[96]; 10 11 int I=0, *p = (int *) buffer; 12 while (i++ &lt; 32) *p++ = (int) buffer; 13 strncpy(buffer, shellcode, 14 strlen(shellcode)); 15 return 0; 16 }
<BR><BR> When the function completes execution and attempts to return control to its caller, the processor will fetch and execute instructions from whatever return address is specified in the corrupted activation frame header.  In a successful attack,
this value will typically point to the base of the injected code, i.e., the address of the stack buffer.  The while-loop in line 12 above writes 32 (4-byte) words into the 96-byte memory block (buffer) pointed by the pointer (p), thus overflowing buffer
and causing the beginning address of the attack code to overwrite the return address for the function.  The strncpy statement in lines 13 and 14 completes phase two of the stack-smashing technique, injecting the attack code into the buffer.  This
injected "shell-code" represents a sequence of Pentium x86 machine instructions to invoke a system call to spawn a shell.
<BR><BR> A slight variation on this theme involves injection of code into non-stack buffers, e.g., buffers in the heap, .bss (un-initialized static data) or static initialized data sections.  In the case of these static data areas, it is easier for the
attacker to determine the exact location of the target buffer, and hence the address of the injected code, since the absolute addresses are determined at link time.  Yet another variation involves overwriting, at least part of the stored frame-pointer
value in the activation record--this forces the attacked function's caller function to trigger the injected code.
<BR><BR> Function-Pointer Overwriting
<BR><BR> This form of attack is similar to the stack-smashing technique in that it involves the use of an unsafe operation with unchecked input data.  The difference lies in the fact that the buffer overflow overwrites some other data that is capable of
altering the control-flow of the process rather than overwriting the return address or the stored frame-pointer value in an activation record.  Various forms of such attacks involve overwriting function pointer variables in C structures, in function
activation records, or in C++ classes.  It is also possible to overwrite entries in the virtual function-pointer table used for implementing polymorphism in C++, or in the global offset table (GOT), to redirect control to malicious injected code.
<BR><BR> In these scenarios, it is not the return from a function body that triggers the attack code, but rather an explicit function invocation (via a function pointer or virtual function) that triggers the injected code.  These attacks are harder to
prevent than the stack-smashing technique, and are often able to circumvent the various stack-based defense mechanisms known in the art.
<BR><BR> Format-String Exploit
<BR><BR> this Attack Technique is Unique in that it does not involve an explicit memory overwrite via any of the unsafe copy operations listed above.  Instead, it exploits the `/.n modifier in C's format strings capability, when combined with dynamically
generated strings, to overwrite specified locations in memory with arbitrary values.  Obviously, this form of attack can be used to circumvent the normal control-flow by overwriting any of the stored return-address in the activation record,
function-pointer variables or entries in various function-pointer tables.
<BR><BR> Return-into-Libc Attack
<BR><BR> Many attack techniques involve some sort of code-injection to alter the normal control-flow of the application.  There are, however, other forms of attacks, known as "return-to-libc" attacks, that leverage existing functionality to cause malice
to the system.  This form of attack also involves overwriting of code pointers.  However, instead of pointing to any injected attack code, these pointers are overwritten to point to the address of libc functions, typically wrapper functions that provide
an indirection to system-call functions.  This attack mechanism is able to reuse existing code in the attacked system to bypass most injected-code detection mechanisms, and is undoubtedly much more difficult to beat.
<BR><BR>SUMMARY OF THE INVENTION
<BR><BR> In one aspect, the invention comprises a monitoring system for detecting and halting execution of malicious code, including a kernel-based system call interposition mechanism, and a libc function interception mechanism.  The kernel-based system
call interposition mechanism detects a system call request from an application, determines a memory region from which the system call request emanates, and halts execution of the code responsible for the call request if the memory region from which the
system call request emanates is a data memory region.  In one embodiment, the data memory region includes writable sections of memory.  In another embodiment, the system call request includes a communication to an operating system kernel to request
interaction with one or more resources.
<BR><BR> In one embodiment, the kernel-based system call interposition mechanism further sets an indicator signaling presence and execution of malicious code, if the memory region from which the system call request emanates is a data memory region.
<BR><BR> In one embodiment, the libc function interception mechanism maintains an alternative wrapper function for each of the relevant standard libc routines, intercepts a call from an application to one or more libc routines and redirects the call into
the corresponding alternative wrapper function.  A stack walk is performed along a dynamic chain of each alternative wrapper function, so as to validate call site memory addresses and target site memory addresses against start limits and end limits,
respectively, for libc routine associated with the alternative wrapper function.
<BR><BR> In one embodiment, an innermost caller-callee pair in the dynamic chain is a direct call function.  Another embodiment includes a process enabling flag.  The kernel-based system call interposition mechanism and the libc function interception
mechanism are enabled to detect and halt execution of malicious code only when the process enabling flag is set.  In another embodiment, the system reports information about the malicious code upon detection of the malicious code.
<BR><BR> In another aspect, the invention comprises a method of detecting and halting execution of malicious code, including interposing system calls by detecting a system call request from an application, determining a memory region from which the
system call request emanates, and halting execution of the code responsible for the call request if the memory region from which the system call request emanates is a data memory region.  The method further includes intercepting libc functions by
maintaining an alternative wrapper function for each of the relevant standard libc routines, intercepting a call from an application to one or more libc routines and redirecting the call into the corresponding alternative wrapper function.
<BR><BR> In one embodiment, the method further includes halting execution of the code responsible, if the memory region from which the system call request emanates includes writable sections of memory.  In another embodiment, the system call request
includes a communication to an operating system kernel to request interaction with one or more resources.
<BR><BR> In another embodiment, the method further includes setting an indicator signaling presence and execution of malicious code if the memory region from which the system call request emanates is a data memory region.  In yet another embodiment, the
method further includes performing a stack walk along a dynamic chain of each alternative wrapper function, so as to validate call site memory addresses and target site memory addresses against start limits and end limits, respectively, for libc routine
associated with the alternative wrapper function.
<BR><BR> In one embodiment, an innermost caller-callee pair in the dynamic chain is a direct call function. <BR><BR>BRIEF DESCRIPTION OF DRAWINGS
<BR><BR> The foregoing and other objects of this invention, the various features thereof, as well as the invention itself, may be more fully understood from the following description, when read together with the accompanying drawings in which:
<BR><BR> FIG. 1 shows one embodiment of a monitoring system for detecting and halting execution of malicious code.
<BR><BR> FIG. 2 illustrates the verification of a single caller-callee function relationship.
<BR><BR> FIG. 3 illustrates a successful, legitimate invocation a system call, and an unsuccessful return-into-libc attempt by malicious code.
<BR><BR>DESCRIPTION OF THE PREFERRED EMBODIMENTS
<BR><BR> The embodiments of a system for and method of detecting and halting malicious code execution described herein are based on principles behind traditional, host-based intrusion-detection systems (IDS).  Such monitoring systems typically infer
program behavior from audit patterns, i.e., the observed sequence of system calls emitted by the running program.  By building models of expected and/or permissible system-call invocations for program execution, an IDS can correlate anomalies in the
observed audit patterns to malicious activity in the program.  The described embodiments also use the system calls emitted by a program as an indication of its behavior, but these embodiments also use specific information associated with the system-call
invocations rather than static models to infer malicious activity.
<BR><BR> FIG. 1 shows one embodiment of a monitoring system 100 for detecting and halting execution of malicious code.  The monitoring system includes a kernel-based system call interposition mechanism 102 and a libc function interception mechanism 104. 
These mechanisms work together to detect and halt different types of malicious code.
<BR><BR> The kernel-based system call interposition mechanism 102 detects and halts malicious invocations of system calls when issued directly by injected code by detecting a system call request 106 from an application, determines 108 the particular
memory region from which the system request emanates, and halts execution 110 of the code responsible for the call request if the particular memory region determined in step 108 is a data memory region.
<BR><BR> The libc function interception mechanism 104 detects and halts a return-into-libc attck, which involves redirecting the control of a program into one of the existing libc functions.  The libc function interception mechanism 104 generates and
maintains 112 an alternative wrapper function, intercepts 114 a call from an application to the libc routines, and redirects 116 the call into the corresponding alternative wrapper function.  Using the alternative wrapper function allows the interception
mechanism 104 to carry out integrity/identity checks of the intermediate functions leading to the libc function call.
<BR><BR> The described embodiments use a kernel-based, system-call interposition technique to utilize this useful vantage point and the "resource manager" role of the operating system kernel to monitor the invocations of system calls.  Similar to normal
function calling conventions in user code, a system-call invocation also stores information (specifically, the program counter value) about the caller code in the program stack.  The system-call handling utility is instrumented in the kernel to perform
additional "read-only code" checks to verify that it was "trusted" code in the application program that made the system-call invocation.  These terms are explained below.
<BR><BR> Trusted, Read-Only Code
<BR><BR> Code that exists in executables and shared library files can generally be trusted to be safe and non-malicious, since it is a direct translation product of hand-written code in a higher-level language or assembler.  This, of course, excludes
program executables that may have been tampered with, or may be infected with a "Trojan horse." This description assumes that all locally available code is trusted and has been kept protected from malicious modifications in a trusted computing base
(TCB), and that the execution of this code does not constitute malicious behavior.
<BR><BR> The process model of the Linux operating system maps the application and library code from the executable sections in Executable and Linking Format (ELF) files to memory pages that are marked read-only.  These pages are write-protected in order
to prevent accidental or intentional overwriting of the program code.  On the other hand, the data sections are mapped to memory pages marked writable.  The delineation of the read-only code memory and the writable data memory for each running process
specified in its Process Control Block (PCB) data structure, and hence the range of memory pages (grouped into "virtual memory regions" in Linux) that are write-protected, i.e., that contain the application and library code, can be determined quite
easily.
<BR><BR> The kernel component of the described embodiments is built into the system call-handler routine in the Linux kernel, where the only verification being carried out originally was whether the specified system call existed on the system.  We
extended this routine to extract the virtual memory address of the trap instruction (referred to as the system call's "return address") in the application or libc code that triggered the system call handler.  To comply with our guidelines for trusted
code, this virtual memory address has to exist in a memory region designated for executable code, and marked read-only in the process memory.  We first determine what virtual memory region contains the system call's return address, and then verify that
this memory region has been marked write-protected.  If a system call request is seen to have emanated from a data memory region, i.e., marked writable, we immediately flag that as an attempt by malicious, injected code, and halt the process.
<BR><BR> Illegal Invocations of System Calls
<BR><BR> Using the definition of trusted code being all those machine instructions executing in the read-only sections of the process memory, one can assume all invocations of system calls by code executing in the writable sections (such as the stack,
heap and static data areas) are malicious.  Hence, when malicious, injected code used commonly in exploits issues a system call, e.g., execve, the kernel in the described embodiment immediately determines that an attack is in progress, and take reactive
steps.
<BR><BR> The result is that malicious code, and also legitimate code that requires an executable stack and heap, is allowed to freely execute on the writable data areas as long as it does not invoke a system call.  Code that legitimately needs to execute
in the stack includes signal return code, trampoline code for nested functions compiled by gcc, longjmp code, and runtime implementations for functional languages like Lisp.  However, exploit code will invariably need to invoke a system call to cause any
out-of-process damage to the system, and consequently will be caught by the checking mechanism in the kernel.
<BR><BR> By making the data areas only partially non-executable, where it is only system-call invocations that are not permitted, the described embodiments manage to avoid the complexities and the overheads of true, prior art non-executable stack and
heap techniques.  These techniques must go to great lengths to make the stack and heap non-executable, e.g., by intercepting page faults to determine if the currently executing machine instruction is in a page marked writable.  Furthermore, a number of
these techniques require sophisticated workarounds to emulate an executable stack for code such as gcc function trampolines and signal handler return code.
<BR><BR> Given that many attack methods need to invoke system calls as part of their execution, the described embodiments are able to defeat such attacks without having to detect or prevent specific cases of buffer overflows or format-string exploits. 
Using this broad approach of not worrying about individual buffers and format strings, the described embodiments are leaner and less intrusive, while being more efficient than the similar prior art techniques.
<BR><BR> Evading the Kernel Checks
<BR><BR> Using the virtual memory address of code that invokes a system call to identify whether it is malicious only works when code that has been injected into the writable data areas makes the system-call invocation directly by issuing a trap
instruction like the stacksmashing code example described herein.  However, more sophisticated attack methods such as "return-into-libc" attacks automatically pass the "read-only code" checks carried out in the system-call handler in the kernel.  Since
these attacks invoke the system-call wrapper functions in the standard C library (libc), the actual machine instruction that issues the trap instruction will be part not of any injected code in the data area, but rather will be from libc.  Hence that
machine instruction will have a virtual memory address that does exist in the read-only part of the process memory.  This form of attack is a response to the various defense techniques that render the stack and heap memory areas non-executable.
<BR><BR> Defeating Return-Into-Libc Attacks
<BR><BR> The described embodiment deflects return-into-libc attacks by requiring the standard library functions to verify the integrity and/or identity of their callers, in an attempt to weed out illegal redirections of program flow of control into libc
functions.  The described embodiment does so by enforcing an automatic check to validate the intermediate callers in each call-sequence leading to the invocation of a libc function.  This checking mechanism, explained next, is the user-mode equivalent of
the system-call interception that takes place in the kernel.  The described embodiment first runs a disassembler, specifically, a modified objdump binary (from the GNU binutils package), to extract the start and end of each function in the program
code--this will be used later to validate callers of functions.  New wrapper functions are created for all the relevant standard library routines.  These wrapper functions are defined in a special shared library (e.g., e-NeXSh.so) interposed between the
application and libc.  The LD_PRELOAD environment variable functionality in the Linux operating system is used to automatically intercept all calls to specific libc functions, and redirect control into the new versions of these functions in e-NeXSh.so.
<BR><BR> Use of the new wrapper functions allows the described embodiment to carry out the integrity/identity checks without having to modify either the application source or binary code.  In each wrapper function, a stack walk is performed along the
"dynamic chain" of intermediate functions starting from main( ) and ending with the function that eventually invoked the libc function.  Doing so yields a list of return addresses for each of the intermediate functions.  The described embodiment verifies
that each of these return addresses exists in the write-protected memory region reserved for the application code, i.e., the .text section.  The described embodiment then inspects the .text section of the process memory to extract and decode each call
instruction preceding the instructions at these return addresses.  The described embodiment then verifies that the absolute target address of this direct call instruction corresponds exactly to the beginning address of the function that is one level
deeper on the call chain, i.e., for each caller-callee pair in the dynamic chain, the described embodiment validates the call site and target site memory addresses against the start and end limits for the relevant functions.  FIG. 2 illustrates the
verification of a single caller-callee function relationship, where "foo" calls "bar." The stack-trace yields the return address of "bar" as 0x0BBF.  This memory address is de-referenced (verifying that it is contained within foo), and the preceding call
instruction is inspected to extract its operand.  This value is 0x0CC0, which is then verified that it matches the starting address of bar.  In this manner, given the return address for "foo calls bar", the machine code (from the .text section) is used
to verify that the caller-callee relationship is legitimate.  These checks are repeated for each return address in the stack-trace until reaching main( ).
<BR><BR> The x86 processor architecture defines other (i.e., indirect) call instructions that are of variable length, and do not encode the true target of the call instructions.  Instead, they utilize indirect addresses stored in registers or the memory
at runtime.  This precludes making bullet-proof guarantees about all possible caller-callee relationships, and forces acceptance of any function as a valid target for an indirect call instruction.  An attacker could then potentially overwrite a function
pointer variable, and cause a redirection of control directly into a libc function.  Such attacks are countered by requiring the innermost caller-callee pair in the dynamic chain (where the application program invokes the libc function) to be a direct
call instruction--a legitimate invocation of libc functions via function pointers in application code is rare, if not unprecedented.  This extra constraint considerably increases the difficulty for an attacker to launch a function pointer-based attack,
given that he has to call a completely different intermediary function that would end up calling the desired libc function.  While such an attack is possible in theory, the actual risk is minimal in practice, based on an analysis of exploits and
vulnerable software.
<BR><BR> In the described embodiment, once the wrapper function has concluded that the current invocation of the libc function is legitimate, it will first inform the kernel to "authorize" any future system-call invocations while the current wrapper is
in scope.  This concludes the libc wrapper checks, and it then resumes the program execution by invoking the original libc function (referenced via explicit dlopen/dlsym calls) in the standard C library.  The execution of the original libc function in
the standard library may involve the invocation of one or more system calls.  Given that system-call authorization is still in effect, the kernel component of described embodiment permits these calls to proceed safely.  Eventually, when the original libc
function completes, the wrapper function again informs the kernel, this time to remove the system-call authorization, and then returns control to the application code.
<BR><BR> On the other hand, a return-into-libc attack will generally transfer control directly into the original libc wrapper function.  Consequently, when the libc function issues any system call(s), the kernel component of the described embodiment will
correctly reject those calls due to their not having been authorized.  In a more sophisticated return-into-libc attack that targets the PLT entries, it is our new libc wrapper that is invoked due to the use of the LD .PRELOAD environment variable.  The
described embodiment detects this attack attempt even earlier when the wrapper function tries to validate the call stack.  In either case, the described embodiment thwarts the return-into-libc attack.
<BR><BR> FIG. 3 illustrates a successful, legitimate invocation of the sys_execve system call by function "foo" in the application code, as well as an unsuccessful return-into-libc attempt by the malicious code shellcode.  The sequence (abcdef) indicates
a successful system-call invocation by "valid" function "foo," being routed through the new execve wrapper function in e-NeXSh.so and the original libc wrapper function execve, in order.  Step (b) represents the operations of the new wrapper function,
starting with the stack-trace and caller-callee verification, and ending with, it informing the kernel to authorize the invocation of sys_execve, before calling the original libc function.  Step (d) signifies the execution of the trap instruction, and
the triggering of the system-call signal handler in the kernel, and step (e) represents the kernel performing its own checks, including the "read-only code" check to verify that the virtual memory address of the calling code is in read-only memory, and
that the currently requested system call is authorized.  The sequence (xde) indicates an unsuccessful return-into-libc attempt by attack code in shellcode to invoke the same system call.  The attack does pass the "read-only code" check at step (e), but
fails the authorisation check in the system call routine because the flow of control did not pass through the authorising call in the new wrapper function
<BR><BR> Theoretically, an extremely determined attacker could try to inject malicious code that replicates the entire stack for a valid run of the program leading to the invocation of the libc wrapper function.  While this is probably impractical to
achieve, the task is made significantly more difficult by randomizing the absolute virtual memory locations of the wrapper functions by using an address-obfuscation technique.  This technique, similar to the one described in [S.  Bhatkar, D. C. DuVarney,
and R. Sekar, "Address Obfuscation: an Efficient Approach to Combat a Broad Range of Memory Error Exploits," In Proceedings of the 12th USENIX Security Symposium, pages 105-120, August 2003], displaces the starting location of the wrapper functions by a
random offset during process loading, vastly increasing the amount of work required to obtain their absolute addresses
<BR><BR> Transparency of Use
<BR><BR> Even though the techniques used in the described embodiment involves modifications to the kernel, these embodiments minimize interference to the system.  For example, these embodiments extend the kernel's Process Control Block (PCB) data
structure that maintains runtime information about all existing processes.  Further, these embodiments add a flag to determine whether the process should be subject to the e-NeXSh protection.  If a process does not have this flag set, its system calls
are not checked to see if they are made from write-protected memory pages.  These embodiments also extend the system call function responsible for process loading, viz., do_execve to set this flag for the current process based on whether any of the
following requirements were met: the program has the environment variable ENX_PROTECT set with the value YES, e.g., run the program as: bash % ENX_PROTECT=YES ./a.out the program's name contains the suffix--enx-protect, or the program image contains an
ELF section titled enexs--a new section can trivially be added to an existing ELF file using the objcopy utility that is part of the GNU binutils package.
<BR><BR> Having the option to selectively protect applications allows one to take any program that does not need the protection and run it unmodified, completely unaffected by the system-call interposition mechanism.  For example, not all programs that
run on a system are subject to external attacks--the focus of the described embodiment is on server software that does need protecting, such as httpd, sendmail, smbd, imapd, and database servers that actually have to interact with possibly malicious
clients on the Internet.
<BR><BR> The invention may be embodied in other specific forms without departing from the spirit or essential characteristics thereof.  The present embodiments are therefore to be considered in respects as illustrative and not restrictive, the scope of
the invention being indicated by the appended claims rather than by the foregoing description, and all changes which come within the meaning and range of the equivalency of the claims are therefore intended to be embraced therein.
<BR><BR><CENTER><b>* * * * *</b></CENTER>
<HR>
   <CENTER>
   <a href=http://pdfpiw.uspto.gov/.piw?Docid=08925090&homeurl=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO2%2526Sect2%3DHITOFF%2526u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%2526r%3D640%2526f%3DG%2526l%3D50%2526d%3DPTXT%2526s1%3D((G06F.CPCL.%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522))%252BAND%252B((power%252BOR%252Belectricity)%252BOR%252Brelay))%2526p%3D13%2526OS%3DCPCL%2FG06F%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522)%252BAND%252B(power%252Bor%252Belectricity%252Bor%252Brelay)%2526RS%3D((CPCL%2FG06F%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522))%252BAND%252B((power%252BOR%252Belectricity)%252BOR%252Brelay))&PageNum=&Rtype=&SectionNum=&idkey=NONE&Input=View+first+page><img src="/netaicon/PTO/image.gif" alt="[Image]" border="0" valign="middle"></A>
   <TABLE>
   <TR><TD align="center"><A href="https://certifiedcopycenter.uspto.gov/other/patft/view.html?backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D640%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3D((G06F.CPCL.%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522))%252BAND%252B((power%252BOR%252Belectricity)%252BOR%252Brelay))%26p%3D13%26OS%3DCPCL%2FG06F%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522)%252BAND%252B(power%252Bor%252Belectricity%252Bor%252Brelay)&backLabel1=Back%20to%20Document%3A%208925090"><IMG border="0" src="/netaicon/PTO/cart.gif" border="0" valign="m
iddle" alt="[View Shopping Cart]"></A>
   <A href="https://certifiedcopycenter.uspto.gov/other/patft/order.html?docNumber=8925090&backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D640%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3D((G06F.CPCL.%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522))%252BAND%252B((power%252BOR%252Belectricity)%252BOR%252Brelay))%26p%3D13%26OS%3DCPCL%2FG06F%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522)%252BAND%252B(power%252Bor%252Belectricity%252Bor%252Brelay)&backLabel1=Back%20to%20Document%3A%208925090">
   <IMG border="0" src="/netaicon/PTO/order.gif" valign="middle" alt="[Add to Shopping Cart]"></A>
   </TD></TR>
   <TR><TD align="center">
     <A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=640&f=S&l=50&d=PTXT&s1=((G06F.CPCL.+AND+(%22intrusion+prevention+system%22+OR+%22intrusion+detection+system%22))+AND+((power+OR+electricity)+OR+relay))&p=12&Query=CPCL/G06F+AND+(&quot;intrusion+prevention+system&quot;+OR+&quot;intrusion+detection+system&quot;)+AND+(power+or+electricity+or+relay)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/prevlist.gif border=0 ALT=[PREV_LIST]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=640&f=S&l=50&d=PTXT&s1=((G06F.CPCL.+AND+(%22intrusion+prevention+system%22+OR+%22intrusion+detection+system%22))+AND+((power+OR+electricity)+OR+relay))&p=13&Query=CPCL/G06F+AND+(&quot;intrusion+prevention+system&quot;+OR+&quot;intrusion+detection+system&quot;)+AND+(power+or+electricity+or+relay)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/hitlist.gif border=0 ALT=[HIT_LIST]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=640&f=S&l=50&d=PTXT&s1=((G06F.CPCL.+AND+(%22intrusion+prevention+system%22+OR+%22intrusion+detection+system%22))+AND+((power+OR+electricity)+OR+relay))&p=14&Query=CPCL/G06F+AND+(&quot;intrusion+prevention+system&quot;+OR+&quot;intrusion+detection+system&quot;)+AND+(power+or+electricity+or+relay)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/nextlist.gif border=0 ALT=[NEXT_LIST]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=639&f=G&l=50&d=PTXT&s1=((G06F.CPCL.+AND+(%22intrusion+prevention+system%22+OR+%22intrusion+detection+system%22))+AND+((power+OR+electricity)+OR+relay))&p=13&OS=CPCL/G06F+AND+(&quot;intrusion+prevention+system&quot;+OR+&quot;intrusion+detection+system&quot;)+AND+(power+or+electricity+or+relay)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/prevdoc.gif border=0 ALT=[PREV_DOC]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=641&f=G&l=50&d=PTXT&s1=((G06F.CPCL.+AND+(%22intrusion+prevention+system%22+OR+%22intrusion+detection+system%22))+AND+((power+OR+electricity)+OR+relay))&p=13&OS=CPCL/G06F+AND+(&quot;intrusion+prevention+system&quot;+OR+&quot;intrusion+detection+system&quot;)+AND+(power+or+electricity+or+relay)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/nextdoc.gif border=0 ALT=[NEXT_DOC]></A>

   <A href="#top"><IMG valign="middle" src="/netaicon/PTO/top.gif" border="0" alt="[Top]"></A>
   </TD></TR>
   </TABLE>
   <A name="bottom"></A>
   <A href="/netahtml/PTO/index.html"><IMG src="/netaicon/PTO/home.gif" alt="[Home]" border="0" valign="middle"></A>
   <A href="/netahtml/PTO/search-bool.html"><IMG src="/netaicon/PTO/boolean.gif" alt="[Boolean Search]" border="0" valign="middle"></A>
   <A href="/netahtml/PTO/search-adv.htm"><IMG border="0" src="/netaicon/PTO/manual.gif" alt="[Manual Search]" valign="middle"></A>
   <A href="/netahtml/PTO/srchnum.htm"><IMG src="/netaicon/PTO/number.gif" alt="[Number Search]" border="0" valign="middle"></A>
   <A href="/netahtml/PTO/help/help.htm"><IMG border="0" src="/netaicon/PTO/help.gif" alt="[Help]" valign="middle"></A>
   </CENTER>
</BODY>
</HTML>