<HTML>
<HEAD>
<BASE target="_top">
<TITLE>United States Patent: 6681331</TITLE></HEAD>
<!-BUF1=6681331
BUF7=2004
BUF8=96952
BUF9=/1/
BUF51=6
-->
<BODY bgcolor="#FFFFFF">
<A name="top"></A>
<CENTER>
<IMG src="/netaicon/PTO/patfthdr.gif" alt="[US Patent & Trademark Office, Patent Full Text and Image Database]">
<BR>
<TABLE>
<TR><TD align="center">
<A href="/netahtml/PTO/index.html"><IMG src="/netaicon/PTO/home.gif" alt="[Home]" border="0" valign="middle"></A>
<A href="/netahtml/PTO/search-bool.html"><IMG src="/netaicon/PTO/boolean.gif" alt="[Boolean Search]" border="0" valign="middle"></A>
<A href="/netahtml/PTO/search-adv.htm"><IMG border="0" src="/netaicon/PTO/manual.gif" ALT="[Manual Search]" valign="middle"></A>
<A href="/netahtml/PTO/srchnum.htm"><IMG src="/netaicon/PTO/number.gif" alt="[Number Search]" border="0" valign="middle"></A>
<A href="/netahtml/PTO/help/help.htm"><IMG border="0" valign="middle" src="/netaicon/PTO/help.gif" ALT="[Help]"></A>
</TD></TR>
<TR><TD align="center">
   <A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1024&f=S&l=50&d=PTXT&s1=((G06F.CPCL.+AND+(%22intrusion+prevention+system%22+OR+%22intrusion+detection+system%22))+AND+((power+OR+electricity)+OR+relay))&p=20&Query=CPCL/G06F+AND+(&quot;intrusion+prevention+system&quot;+OR+&quot;intrusion+detection+system&quot;)+AND+(power+or+electricity+or+relay)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/prevlist.gif border=0 ALT=[PREV_LIST]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1024&f=S&l=50&d=PTXT&s1=((G06F.CPCL.+AND+(%22intrusion+prevention+system%22+OR+%22intrusion+detection+system%22))+AND+((power+OR+electricity)+OR+relay))&p=21&Query=CPCL/G06F+AND+(&quot;intrusion+prevention+system&quot;+OR+&quot;intrusion+detection+system&quot;)+AND+(power+or+electricity+or+relay)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/hitlist.gif border=0 ALT=[HIT_LIST]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1023&f=G&l=50&d=PTXT&s1=((G06F.CPCL.+AND+(%22intrusion+prevention+system%22+OR+%22intrusion+detection+system%22))+AND+((power+OR+electricity)+OR+relay))&p=21&OS=CPCL/G06F+AND+(&quot;intrusion+prevention+system&quot;+OR+&quot;intrusion+detection+system&quot;)+AND+(power+or+electricity+or+relay)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/prevdoc.gif border=0 ALT=[PREV_DOC]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1025&f=G&l=50&d=PTXT&s1=((G06F.CPCL.+AND+(%22intrusion+prevention+system%22+OR+%22intrusion+detection+system%22))+AND+((power+OR+electricity)+OR+relay))&p=21&OS=CPCL/G06F+AND+(&quot;intrusion+prevention+system&quot;+OR+&quot;intrusion+detection+system&quot;)+AND+(power+or+electricity+or+relay)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/nextdoc.gif border=0 ALT=[NEXT_DOC]></A>

<A href="#bottom"><IMG src="/netaicon/PTO/bottom.gif" alt="[Bottom]" valign="middle" border="0"></A>
</TD></TR>
   <TR><TD align="center">
   <A href="https://certifiedcopycenter.uspto.gov/other/patft/view.html?backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D1024%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3D((G06F.CPCL.%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522))%252BAND%252B((power%252BOR%252Belectricity)%252BOR%252Brelay))%26p%3D21%26OS%3DCPCL%2FG06F%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522)%252BAND%252B(power%252Bor%252Belectricity%252Bor%252Brelay)&backLabel1=Back%20to%20Document%3A%206681331"><IMG border="0" src="/netaicon/PTO/cart.gif" border="0" valign="middle" alt="[View Shopp
ing Cart]"></A>
   <A href="https://certifiedcopycenter.uspto.gov/other/patft/order.html?docNumber=6681331&backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D1024%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3D((G06F.CPCL.%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522))%252BAND%252B((power%252BOR%252Belectricity)%252BOR%252Brelay))%26p%3D21%26OS%3DCPCL%2FG06F%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522)%252BAND%252B(power%252Bor%252Belectricity%252Bor%252Brelay)&backLabel1=Back%20to%20Document%3A%206681331">
   <IMG border="0" src="/netaicon/PTO/order.gif" valign="middle" alt="[Add to Shopping Cart]"></A>
   </TD></TR>
   <TR><TD align="center">
   <a href=http://pdfpiw.uspto.gov/.piw?Docid=06681331&homeurl=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO2%2526Sect2%3DHITOFF%2526u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%2526r%3D1024%2526f%3DG%2526l%3D50%2526d%3DPTXT%2526s1%3D((G06F.CPCL.%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522))%252BAND%252B((power%252BOR%252Belectricity)%252BOR%252Brelay))%2526p%3D21%2526OS%3DCPCL%2FG06F%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522)%252BAND%252B(power%252Bor%252Belectricity%252Bor%252Brelay)%2526RS%3D((CPCL%2FG06F%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522))%252BAND%252B((power%252BOR%252Belectricity)%252BOR%252Brelay))&PageNum=&Rtype=&SectionNum=&idkey=NONE&Input=View+first+page><img src="/netaicon/PTO/image.gif" alt="[Image]" border="0" valign="middle"></A>

   </TD></TR>
</TABLE>
</CENTER>
<TABLE width="100%">
<TR><TD align="left" width="50%">&nbsp;</TD>
<TD align="right" valign="bottom" width="50%"><FONT size="-1">( <STRONG>1024</STRONG></FONT> <FONT size=-2>of</FONT> <STRONG><FONT size=-1>1029</STRONG> )</FONT></TD></TR></TABLE>
<HR>
   <TABLE width="100%">
   <TR>	<TD align="left" width="50%"><b>United States Patent </b></TD>
   <TD align="right" width="50%"><b>6,681,331</b></TD>
   </TR>
     <TR><TD align="left" width="50%"><b>
         Munson
, &nbsp; et al.</b>
     </TD>
     <TD align="right" width="50%"> <b>
     January 20, 2004
</b></TD>
     </TR>
     </TABLE>
       <TABLE width="100%">
       <TR>
       <TD align="center" width="100%"><FONT size="-2"><b>**Please see images for: </b>
         <FONT size="-2"><b>( Certificate of Correction ) </b>
       <FONT size="-2"><b> **</b>
       </TD>
       </TR>
       </TABLE>
       <HR>
       <FONT size="+1"> Dynamic software system intrusion detection
</FONT><BR>
       <BR><CENTER><b>Abstract</b></CENTER>
       <p>A real-time approach for detecting aberrant modes of system behavior
     induced by abnormal and unauthorized system activities that are indicative
     of an intrusive, undesired access of the system. This detection
     methodology is based on behavioral information obtained from a suitably
     instrumented computer program as it is executing. The theoretical
     foundation for the present invention is founded on a study of the internal
     behavior of the software system. As a software system is executing, it
     expresses a set of its many functionalities as sequential events. Each of
     these functionalities has a characteristic set of modules that is executed
     to implement the functionality. These module sets execute with clearly
     defined and measurable execution profiles, which change as the executed
     functionalities change. Over time, the normal behavior of the system will
     be defined by the boundary of the profiles. An attempt to violate the
     security of the system will result in behavior that is outside the normal
     activity of the system and thus result in a perturbation of the system in
     a manner outside the scope of the normal profiles. Such violations are
     detected by an analysis and comparison of the profiles generated from an
     instrumented software system against a set of known intrusion profiles and
     a varying criterion level of potential new intrusion events.
</p>
       <HR>
<TABLE width="100%"> <TR> <TH scope="row" valign="top" align="left" width="10%">Inventors:</TH> <TD align="left" width="90%">
 <B>Munson; John C.</B> (Moscow, ID)<B>, Elbaum; Sebastian G.</B> (Moscow, ID) </TD> </TR>
<TR> <TH scope="row" valign="top" align="left" width="10%">Assignee:</TH>
<TD align="left" width="90%">

<B>Cylant, Inc.</B>
 (Katonah, 
NY)
<BR>

</TD>
</TR>
       <TR><TH scope="row" valign="top" align="left" width="10%" nowrap>Family ID:
       </TD><TD align="left" width="90%">
       <b>23199550
</b></TD></TR>
       <TR><TH scope="row" valign="top" align="left" width="10%" nowrap>Appl. No.:
       </TH><TD align="left" width="90%">
       <b> 09/309,755</b></TD></TR>
       <TR><TH scope="row" valign="top" align="left" width="10%">Filed:
       </TH><TD align="left" width="90%">
       <b>May 11, 1999</b></TD></TR>
     </TABLE>
     <HR>
<p> <TABLE width="100%"> <TR><TD valign="top" align="left" width="30%"><b>Current U.S. Class:</b></TD> <TD valign="top" align="right" width="70%"><b>726/23</b>; 714/E11.209; 714/E11.218 </TD></TR> 
       <TR><TD valign="top" align="left" width="30%"><b>Current CPC Class: </b></TD>
       <TD valign="top" align="right" width="70%">G06F 11/3612&nbsp(20130101); G06F 21/55&nbsp(20130101); G06F 21/552&nbsp(20130101); G06F 11/30&nbsp(20130101)</TD></TR>
         <TR><TD valign="top" align="left" width="30%"><b>Current International Class: </b></TD>
         <TD valign="top" align="right" width="70%">G06F 11/36&nbsp(20060101); G06F 21/00&nbsp(20060101); G06F 011/30&nbsp()</TD></TR>
       <TR><TD valign="top" align="left" width="30%"><b>Field of Search: </b></TD>
       <TD align="right" valign="top" width="70%">
       











 ;713/200,201 ;709/223,224 ;706/15,16,21,22,45-48,50,61,62
       </TD></TR>
     </TABLE>
<HR><CENTER><b>References Cited  <A href="/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2Fsearch-adv.htm&r=0&f=S&l=50&d=PALL&Query=ref/6681331">[Referenced By]</A></b></CENTER>       <HR>
       <CENTER><b>U.S. Patent Documents</b></CENTER>
<TABLE width="100%"> <TR><TH scope="col" width="33%"></TH> <TH scope="col" width="33%"></TH> <TH scope="col" width="34%"></TH></TR> <TR> <TD align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F5067073">5067073</a></TD><TD align =left>
November 1991</TD><TD align=left>
Andrews</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F5278901">5278901</a></TD><TD align =left>
January 1994</TD><TD align=left>
Shieh et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F5313616">5313616</a></TD><TD align =left>
May 1994</TD><TD align=left>
Cline et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F5355487">5355487</a></TD><TD align =left>
October 1994</TD><TD align=left>
Keller et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F5487131">5487131</a></TD><TD align =left>
January 1996</TD><TD align=left>
Kassatly et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F5499340">5499340</a></TD><TD align =left>
March 1996</TD><TD align=left>
Barritz</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F5528753">5528753</a></TD><TD align =left>
June 1996</TD><TD align=left>
Fortin</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F5539907">5539907</a></TD><TD align =left>
July 1996</TD><TD align=left>
Srivastava et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F5557742">5557742</a></TD><TD align =left>
September 1996</TD><TD align=left>
Smaha et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F5581482">5581482</a></TD><TD align =left>
December 1996</TD><TD align=left>
Wiedenman et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F5621889">5621889</a></TD><TD align =left>
April 1997</TD><TD align=left>
Lermuzeaux et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F5675711">5675711</a></TD><TD align =left>
October 1997</TD><TD align=left>
Kephart et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F5732273">5732273</a></TD><TD align =left>
March 1998</TD><TD align=left>
Srivastava et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F5790858">5790858</a></TD><TD align =left>
August 1998</TD><TD align=left>
Vogel</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F5907834">5907834</a></TD><TD align =left>
May 1999</TD><TD align=left>
Kephart et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F5987250">5987250</a></TD><TD align =left>
November 1999</TD><TD align=left>
Subrahmanyam</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F5991881">5991881</a></TD><TD align =left>
November 1999</TD><TD align=left>
Conklin et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6009514">6009514</a></TD><TD align =left>
December 1999</TD><TD align=left>
Henzinger et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6026236">6026236</a></TD><TD align =left>
February 2000</TD><TD align=left>
Fortin et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6094530">6094530</a></TD><TD align =left>
July 2000</TD><TD align=left>
Brandewie</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6119236">6119236</a></TD><TD align =left>
September 2000</TD><TD align=left>
Shipley</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6226408">6226408</a></TD><TD align =left>
May 2001</TD><TD align=left>
Sirosh</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6282701">6282701</a></TD><TD align =left>
August 2001</TD><TD align=left>
Wygodny et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6321338">6321338</a></TD><TD align =left>
November 2001</TD><TD align=left>
Porras et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6347374">6347374</a></TD><TD align =left>
February 2002</TD><TD align=left>
Drake et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6370648">6370648</a></TD><TD align =left>
April 2002</TD><TD align=left>
Diep</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6405318">6405318</a></TD><TD align =left>
June 2002</TD><TD align=left>
Rowland</TD></TR><TR><TD align=left>

</TD>
</TR> </TABLE>
<TABLE width="90%"> <BR> <CENTER><b>Other References</b></CENTER> <TR><TD><align="left"><BR>Frank, "Artificial Intelligence and Intrusion Detection: Current and Future Directions" Jun. 9, 1994, Division of Computer Science University of California
at Davis, p. 1-12.*
.<BR>"Real-time attack recognition and response: A solution for tightening network security" 1997, Internet Security Systems, p. 1-13.*
.<BR>Lankewicz et al, "Real-time Anomaly Detection Using a Nonparametric Pattern Recognition Approach", 1991, IEEE, p. 80-89.*
.<BR>Cannady, "Artificial Neural Networks for Misuse Detection" Oct. 1998, School of Computer and Information Sciences Nova Southeastern University, p. 1-14.*
.<BR>Cannady et al, "The Application of Artificial Neural Networks to Misuse Detection: Initial Results", Mar. 10, 1997, Georgia Tech Research Institute Georgia Institute of Technology, p. 1-13.*
.<BR>Herringshaw, "Detecting Attacks on Networks" Dec. 1997, Industry Trends, p. 16-17.*
.<BR>Mukherjee et al., "Network Intrusion Detection" May/Jun. 1994, IEEE Network, p. 26-41.*
.<BR>Lane et al, "Sequence Matching and Learning in Anomaly Detection for Computer Security" 1997, School of Electrical and Computer Engineering Purdue University, p. 1-7.*
.<BR>Dasgupta, D. et al., "Novelty Detection in Time Series Data Using Ideas from Immunology," 1995, 6 pages.
.<BR>D'haeseleer, P. et al., "A Distributed Approach to Anomaly Detection," Aug. 30, 1997, 30 pages.
.<BR>D'haeseleer, P. et al., "An Immunology Approach to Change Detection: Algorithms, Analysis and Implications," IEEE Symposium on Security and Privacy, 1996, 10 pages.
.<BR>Forrest, S. et al., "Computer Immunology," Comm. of the ACM, Mar. 21, 1996, 18 pages.
.<BR>Forrest, S. et al., "Self-Nonself Discrimination in a Computer," Proceedings of IEEE Symposium on Research in Security and Privacy, 1994, 11 pages.
.<BR>Hofmeyr, S.A., "Intrusion Detection Using Sequence of System Calls," Dec. 17, 1997, 41 pages.
.<BR>Hofmeyr, S.A. et al., "Architecture for an Artificial Immune System," 2000, 31 pages.
.<BR>Somayaji, A. et al., "Automated Response Using System-Call Delays," Proceedings of the 9.sup.th USENIX Security Simposium, Aug. 14-17, 2000, 13 pages.
.<BR>Somayaji, A. et al., "Principles of a Computer Immune System," ACM, New Security Paradigms Workshop, Langdale, Cumbria UK, 1998, 75-82.
.<BR>Warrender, C. et al., "Detecting Intrusions Using System Calls: Alternative Data Models," IEEE Computer Society, Symposium on Security and Privacy, 1999, 133-145.
.<BR>Anderson, D. et al., "Next-generation intrusion detection expert system (NIDES)," Technical Report, Computer Science Laboratory, SRI International, Menlo Park, CA, SRI-CSL-95-07, May, 1995, 1-37 (plus 6 additional pages).
.<BR>Anderson, D. et al., "Detecting Unusual Program Behavior Using the Statistical Component of the Next-generation Intrusion Detection Expert System (NIDES)," SRI-CSL-95-06, SRI International, Menlo Park, CA, May, 1995, 1-71, 73-75, 77 (plus 6
additional pages).
.<BR>Aslam, T. et al., "Use of A Taxonomy of Security Faults," Technical Report TR-96-051, Coast Lab., Purdue University, presented at 19th National Information Systems Security Conference, Sep., 1996, 1-10.
.<BR>Ball, T. et al., "Optimally Profiling and Tracing Programs," Technical Report #1031, University of Wisconsin, Computer Science Dep., Sep., 1991, 1-27.
.<BR>Bishop, M., "A Standard Audit Log Format," Proc. of the 18th National Information Systems Security Conference, 1995, 136-145.
.<BR>Bishop, M., "Profiling Under UNIX by Patching," Software-Practice and Exp., Oct. 1987, 17(10), 729-739.
.<BR>Crosbie, M. et al., "Defending a Computer System using Autonomous Agents," Technical Report No. 95-022, Coast Laboratory, Dept. of Computer Sciences, Purdue University, Mar., 1994, 1-11.
.<BR>Denning, D., "An Intrusion-Detection Model," IEEE Transactions on Software Engineering, Feb., 1987, 13(2), 222-232.
.<BR>Elbaum, S. et al., "Intrusion Detection through Dynamic Software Measurement," Proc. Usenix Workshop on Intrusion Detection and Network Monitoring, Santa Clara, California, Apr. 9-12, 1999, 1-10.
.<BR>Graham, S.L. et al., "An Execution Profiler for Modular Programs," Software-Practice and Exp., 1983, 13, 671-685.
.<BR>Hall, R.J., "Call Path Profiling," Proc. 14.sup.th Int'l Conf. Soft. Engineering, ACM, 1992, 296-306.
.<BR>Halme, L. et al., "AINT misbehaving--a Taxonomy of Anti-intrusion Techniques," Proc. of the 18th National Information Systems Security Conference, 1995, 13 pages.
.<BR>Hochberg, J. et al., "NADIR: An Automated System for Detecting Network Intrusion and Misuse," Computers & Security, 1993, 12(3), 235-248.
.<BR>Ilgun, K., "USTAT: A Real-time <A Name=h1 HREF=#h0></A><A  HREF=#h2></A><B><I>Intrusion Detection System</I></B> for UNIX," Proc. of the IEEE Symposium on Research in Security and Privacy, May 24-26, 1993, 16-28.
.<BR>Javitz, H. et al., "The SRI IDES Statistical Anomaly Detector," Proc. of the IEEE Symposium on Research in Security and Privacy, May 20-22, 1991, 316-326.
.<BR>Johnson, "Profiling for Fun and Profit," USENIX Winter '90 Conference Proceedings, 1990, 325-330.
.<BR>Jonsson, E. et al., "A Quantitative Model of the Security Intrusion Process Based on Attacker Behavior," IEEE Transactions of Software Engineering, Apr., 1997, 23(4), 235-245.
.<BR>Kumar, S. et al., "A Pattern Matching Model for Misuse Intrusion Detection," Proc. of the 17th National Computer Security Conference, Coast Laboratory, Dept. of Computer Sciences, Purdue University, Oct., 1994, 11-21.
.<BR>Kumar, S. et al., "A Software Architecture to Support Misuse Intrusion Detection," Proc. of 18th National Information Systems Conference, Coast Laboratory, Dept. of Computer Sciences, Purdue University, Mar., 1995, 1-17.
.<BR>Lankewicz, L. et al., "Real-Time Anomaly Detection Using a Nonparametric Pattern Recognition Approach," Seventh Annual Computer Security Applications Conference, San Antonio, Texas, Dec. 2-6, 1991, 80-89.
.<BR>Larus, J.R., "Abstract Execution: A Technique for Efficiently Tracing Programs," Software-Practice and Experience, Dec., 1990, 20(12), 1241-1258.
.<BR>Larus, J.R. et al., "Rewriting Executable Files to Measure Program Behavior," Technical Report #1083, University of Wisconsin, Computer Science Dep., Mar. 25, 1992, 1-17.
.<BR>Lunt, T., "A Survey of Intrusion Detection Techniques," Computer & Security, 1993, 12, 405-418.
.<BR>Mukherjee, B. et al., "Network Intrusion Detection," IEEE Network, May/Jun., 1994, 8(3), 26-41.
.<BR>Munson, J., "A Functional Approach to Software Reliability Modeling," In Quality of Numerical Software, Assessment and Enhancement, Boisvert (ed.), Chapman & Hall, London, 1997, 61-76.
.<BR>Petersen, K., "IDA--Intrusion Detection Alert," Proc. of the IEEE Annual International Computer Software and Applications Conference, Chicago, IL, Sep. 21-25, 1992, 306-311.
.<BR>Porras, P. et L., "Penetration State Transition Analysis--A Rule-Based Intrusion Detection Approach," Eighth Annual Computer Security Applications Conference, IEEE Computer Society Press, Nov. 30-Dec. 4, 1992, 220-229.
.<BR><A Name=h2 HREF=#h1></A><A  HREF=#h3></A><B><I>Power,</I></B> L.R., "Design and use of a program execution analyzer," IBM Systems J., 1983, 22(3), 271-294.
.<BR>Puketza, N. et al., "A Methodology for Testing Intrusion Detection Systems," IEEE Transactions on Software Engineering, Oct., 1996, 22(10), 719-729.
.<BR>Shieh et al., "A Pattern-Oriented intrusion-Detection Model and Its Applications," Proc. of the 1991 IEEE Symposium on Research in Security and Privacy, Oakland, Calif., May 20-22, 1991, 327-342.
.<BR>Smaha, S., "Haystack: An <A Name=h3 HREF=#h2></A><A  HREF=#h4></A><B><I>Intrusion Detection System,</I></B>" Proceedings of the Fourth Aerospace Computer Security Applications Conference, Orlando, Florida, IEEE Computer Society, Dec. 12-16, 1988, 37-44.
.<BR>Smith, M.D., "Tracing with Pixie," Stanford University Technical Report No. CSL-TR-91-497, Apr. 4, 1991, 1-29.
.<BR>Sobirey, M. et al., "The <A Name=h4 HREF=#h3></A><A  HREF=#h5></A><B><I>Intrusion Detection System</I></B> AID. Architecture, and Experiences in Automated Audit Analysis," Proc. of the International Conference on Communications and Multimedia Security, Sep. 23-24, 1996, 278-290.
.<BR>Speer, S.E., "Improving UNIX Kernel Performance Using Profile Based Optimization," Winder USENIX, Jan. 17-21, 1994, 181-188.
.<BR>Teng, H. et al., "Adaptive Real-Time Anomaly Detection Using Inductively Generated Sequential Patterns," Proc. of the IEEE Symposium on Research in Security and Privacy, Oakland, CA, May 7-9, 1990, 278-284.
.<BR>Vaccaro, H. et al., "Detection of Anomalous Computer Session Activity," Proc. of the IEEE Symposium on Research in Security and Privacy, Oakland, CA, May 1-3, 1989, 280-289.
.<BR>Wall, D.W., "Global Register Allocation at Link Time," Digital Equipment Corporation, WRL Research Report 86/3, Oct., 1986 1-20.. </TD></TR> </TABLE> <BR>
       <i>Primary Examiner:</i>  Sheikh; Ayaz
<BR>
       <i>Assistant Examiner:</i>  Revak; Christopher
<BR>
       <i>Attorney, Agent or Firm:</i> <coma>Woodcock Washburn LLP
<BR>
         <HR>
<CENTER><b><i>Claims</b></i></CENTER> <HR> <BR><BR>The invention in which an exclusive right is claimed is defined by the following: <BR><BR>1.  A method for detecting an intrusive use of a computer system through the dynamic measurement of software
activity, comprising the steps of: (a) within an internal operating environment on the computer system, but not limited to an operating system, causing the computer system to monitor control transfer respectively to and possibly from each of a plurality
of program modules executing on the computer system, and execution profile data, said execution profile data identifying the modules that have executed within a period of time;  (b) at least temporarily retaining the execution profile data;  (c)
estimating a nominal computer system behavior as a function of said execution profile data, while no intrusive use of the computer system is occurring;  and (d) detecting at least a potential intrusive use, if a change in the execution profile data
indicates computer system behavior that deviates substantially from the nominal computer system behavior.
<BR><BR>2.  The method of claim 1, further comprising the step of indicating that at least the potential intrusive use of a selected program running on the computer system has occurred by registering an alarm.
<BR><BR>3.  A method for detecting an intrusive use of a computer system, comprising the steps of: within an internal operating environment on the computer system, but not limited to an operating system, causing the computer system to monitor transfer of
control to and from each of a plurality of program modules executing on the computer system, and producing execution profile data identifying the modules that have executed within a period of time;  at least temporarily retaining the execution profile
data;  estimating a nominal computer system behavior as a function of said execution profile data, while no intrusive use of the computer system is occurring;  and detecting at least a potential intrusive use based on the execution profile data;  wherein
the step of estimating the nominal computer system behavior comprises the steps of: (a) periodically identifying all of the program modules that executed during a current interval;  (b) periodically determining a frequency with which each program module
executed during the current interval;  (c) as a function of the program modules that executed during the current interval and the frequency with which each program module executed, determining an execution profile;  (d) at least temporarily retaining
execution profiles for successive intervals.
<BR><BR>4.  The method of claim 3, further comprising the step of normalizing the frequency for each program module when determining each execution profile.
<BR><BR>5.  The method of claim 4, further comprising the steps of: (a) producing an execution profile for each successive interval, said execution profile indicating frequencies with which control has been transferred between specific program modules
during the interval, each such transfer of control comprising a module transition;  and (b) at least temporarily retaining execution profiles for successive intervals.
<BR><BR>6.  The method of claim 4, further comprising the steps of: (a) periodically mapping a sequence of module transitions representing subtrees into function sequences by mapping program functionalities to specific program modules that have executed
during the current interval, producing function sequences for the current interval;  and (b) at least temporarily retaining the function sequences for successive intervals.
<BR><BR>7.  The method of claim 6, further comprising the steps of comparing the nominal computer system behavior with the execution profile for the current interval to determine whether any substantial difference exists that exceeds a predetermined
threshold, and if so determining that at least the potential intrusive use of the computer system has occurred.
<BR><BR>8.  The method of claim 7, wherein if a potential intrusive use of the computer system has been detected, further comprising the steps of: (a) providing a database of normal profiles, each profile corresponding to a known normal usage of the
computer system;  (b) comparing the execution profile for the current interval with the database of normal profiles to determine if a departure from the normal profiles exists;  and if so (c) indicating that an intrusive use of the computer system has
occurred.
<BR><BR>9.  The method of claim 7, wherein if a potential intrusive use of the computer system has been detected, further comprising the steps of: (a) providing a database of normal profiles, each profile having an associated transition matrix and
corresponding to a known normal use of the computer system;  (b) comparing the execution profile for the current interval with the database of intrusion profiles to determine if a difference with the execution profile associated with each of the normal
profiles exists;  and if so (c) indicating that an intrusive use of the computer system has occurred.
<BR><BR>10.  The method of claim 7, wherein if a potential intrusive use of the computer system has been detected, further comprising the steps of: (a) providing a database of execution profiles, each execution profile having an associated functional
profile and corresponding to a known intrusive use of the computer system;  (b) comparing the functional profile for the current interval with the database of normal profiles to determine if a difference exists with the functional profile associated with
one of the intrusion profiles exists;  and if so (c) indicating that an intrusive use of the computer system has occurred.
<BR><BR>11.  The method of claim 7, further comprising the step of controlling a duration of subsequent intervals as a function of a variance of said difference.
<BR><BR>12.  The method of claim 1, further comprising the steps of creating a database of execution profiles, each execution profile corresponding to a known intrusive use of the computer system, an execution profile for each new detected intrusive use
being added to the database of execution profiles, if not already included therein.
<BR><BR>13.  The method of claim 1, further comprising the step of producing one of a plurality of different levels of alarms in response to a probability of an intrusive use of the computer system having been detected as indicated by changes in the
dynamic measurements of program activity, wherein a higher level alarm is produced as the probability of an intrusive use increases.
<BR><BR>14.  The method of claim 1, wherein the internal operating environment comprises at least one of: (a) an operating system executing on a web server;  (b) an operating system in which a database program is executed;  (c) an operating system shell; and (d) a file management system.
<BR><BR>15.  A method for detecting an intrusive or an anomalous use of a computer program executing on a computer through the dynamic measurement of the computer program, said computer program comprising a plurality of program modules, comprising the
steps of: (a) providing a call to a mapping module, at each entry point into a program module and before each return to a program module within the computer program;  (b) using the mapping module to monitor execution profiles of program modules in
response to each call, producing program module sequence data that indicate a sequence of program modules executing during successive defined sampling intervals and a frequency with which each such program module executed during each sampling interval; 
(c) at least temporarily storing the program module sequence data provided by the mapping module for successive sampling intervals;  (d) providing a nominal set of data that represent a substantially steady state behavior of the computer program while
executing with no intrusive or anomalous use;  and (e) employing at least one of a plurality of detection modes that detect an intrusive or an anomalous use of the computer program as a function of both the program module sequence data and the nominal
set of data, by determining if a level of internal activity of the computer program differs substantially from an accepted range of nominal activity by the computer program.
<BR><BR>16.  The method of claim 15, further comprising the step of normalizing the frequency with which each program module executes during each successive sampling interval, producing an execution profile for each successive sampling interval, one of
said plurality of detection modes comprising the steps of comparing a current execution profile for a most recent sampling interval with the nominal set of data to determine if there is a substantial difference, and if so, indicating that an intrusive or
anomalous use of the computer program may have occurred.
<BR><BR>17.  A method for detecting an intrusive or an anomalous use of a computer program executing on a computer, said computer program comprising a plurality of program modules, comprising the steps of: (a) providing calls to a mapping module, at
prescribed entry and return points in a plurality of program modules within the computer program;  (b) using the mapping module to monitor execution profiles of program modules, and producing program module sequence data that indicate a sequence of
program modules executing during successive defined sampling intervals and a frequency with which each such program module executed during each sampling interval;  (c) at least temporarily storing the program module sequence data provided by the mapping
module for successive sampling intervals;  (d) providing a nominal set of data that represent a substantially steady state behavior of the computer program while executing with no intrusive or anomalous use;  (e) employing at least one of a plurality of
detection modes that detect an intrusive or an anomalous use of the computer program as a function of both the program module sequence data and the nominal set of data, by determining if a level of internal activity of the computer program differs
substantially from an accepted range of nominal activity by the computer program;  and further comprising the step of creating an execution profile for each sampling interval from the program module sequence data that indicates frequencies with which
execution of the computer program caused a transition between different program modules during the successive sampling intervals, one of said plurality of detection modes comprising the steps of comparing a current transition matrix for a most recent
sampling interval with the nominal set of data to determine if there is a substantial difference, and if so, indicating that an intrusive or anomalous use of the computer program may have occurred.
<BR><BR>18.  The method of claim 15, further comprising the step of mapping the sequence of program modules that have executed during each successive sampling interval into function sequences by mapping program functionalities to the program modules,
producing functional profiles for the successive sampling intervals, one of said plurality of detection modes comprising the steps of comparing current functional profiles for a most recent sampling interval with the nominal set of data to determine if
there is a substantial difference, and if so, indicating that an intrusive or anomalous use of the computer program may have occurred.
<BR><BR>19.  The method of claim 15, further comprising the steps of: (a) providing known intrusion profile data indicating activity occurring during different intrusive or anomalous uses of the computer program;  (b) comparing a current execution
profile for a most recent sampling interval derived from the program module sequence data with the known intrusion profile data;  and (c) if the current execution profile substantially matches any of the known intrusion profile data, positively
determining that an intrusive or anomalous use of the computer program has occurred.
<BR><BR>20.  The method of claim 15, further comprising the step of raising an alarm if it appears that an intrusive or anomalous use of the computer program has occurred as indicated by a change in the execution profiles.
<BR><BR>21.  The method of claim 15, further comprising the step of raising one of a plurality of different levels of alarm, the level of alarm raised depending upon a probability that an intrusive or anomalous use of the computer program has occurred as
indicated by a change in the execution profiles.
<BR><BR>22.  The method of claim 15, further comprising the step of varying a duration of the sampling interval as a function of an extent of computational activity occurring during current sampling intervals as indicated by a change in the execution
profiles.
<BR><BR>23.  The method of claim 15, wherein the step of providing a call to a mapping module comprises the step of adding the calls to the computer program.
<BR><BR>24.  The method of claim 15, wherein the step of providing a call to a mapping module comprises the step of adding a hardware monitor that transmits the call to the mapping module upon detecting an entry into any of the plurality of program
modules and upon detecting a return from any of the plurality of program modules.
<BR><BR>25.  A computer-readable memory medium on which are stored a plurality of computer-executable instructions for performing steps (a)-(e), as recited in claim 15.
<BR><BR>26.  A computer-readable memory medium on which are stored a plurality of computer-executable instructions for performing the steps of the method of claim 16.
<BR><BR>27.  A computer-readable memory medium on which are stored a plurality of computer-executable instructions for performing the steps of the method of claim 17.
<BR><BR>28.  A computer-readable memory medium on which are stored a plurality of computer-executable instructions for performing the steps of the method of claim 18.
<BR><BR>29.  A computer-readable memory medium on which are stored a plurality of computer-executable instructions for performing the steps of the method of claim 19.
<BR><BR>30.  Apparatus on which a computer program is executable, said apparatus being capable of detecting an intrusive or anomalous use of the computer program, comprising: (a) a processor;  and (b) a memory coupled to the processor, said memory
storing machine instructions that when executed by the processor implement the computer program and further, implement a plurality of functions, including: (i) providing a call to a mapping module, at each entry point into a program module and possibly
before each return to a program module within the computer program;  (ii) using the mapping module to monitor transitions between program modules in response to each call, producing program module sequence data that indicate a sequence of program modules
executing on the processor during successive defined sampling intervals and a frequency with which each such program module executed during each sampling interval;  (iii) at least temporarily storing the program module sequence data provided by the
mapping module for successive sampling intervals in the memory;  (iv) providing a nominal set of data in the memory, said nominal set of data representing a substantially steady state behavior of the computer program while executing on the processor with
no intrusive or anomalous use;  and (v) employing at least one of a plurality of detection modes that detect an intrusive or an anomalous use of the computer program as a function of both the program module sequence data and the nominal set of data, by
determining if a level of internal activity of the computer program differs substantially from an accepted range of nominal activity by the computer program.
<BR><BR>31.  The apparatus of claim 30, wherein the machine instructions further cause the processor to normalize the frequency with which each program module executes during each successive sampling interval, producing an execution profile for each
successive sampling interval, one of said plurality of detection modes including comparing a current execution profile for a most recent sampling interval with the nominal set of data to determine if there if a substantial difference, and if so, causing
the processor to indicate that an intrusive or anomalous use of the computer program may have occurred.
<BR><BR>32.  Apparatus on which a computer program is executable, said apparatus being capable of detecting an intrusive or anomalous use of the computer program, comprising: (a) a processor;  and (b) a memory coupled to the processor said memory storing
machine instructions that when executed by the processor implement the computer program and further, implement a plurality of functions, including: (i) providing a call to a mapping module, at each entry point into a program module and possibly also
before each return to a program module within the computer program;  (ii) using the mapping module to monitor transitions between programs modules in response to each control transition, producing program module sequence data that indicate a sequence of
program modules executing on the processor during successive defined sampling intervals and a frequency with which each such program module executed during each sampling interval;  (iii) at least temporarily storing the program module sequence data
provided by the mapping module for successive sampling intervals in the memory;  (iv) providing a nominal set of data in the memory, said nominal set of data representing a substantially steady state behavior for the computer program while executing on
the processor with no intrusive or anomalous use;  and (v) employing at least one of a plurality of detection modes that detect an intrusive or an anomalous use of the computer program as a function of both the program module sequence data and the
nominal set of data, by determining if a level of internal activity of the computer program differs substantially from an accepted range of nominal activity by the computer program;  wherein the machine instructions further cause the processor to create
a transition matrix in the memory for each sampling interval from the program module sequence data, the transition matrix indicating frequencies with which execution of the computer program by the processor caused a transition between different program
modules during the successive sampling intervals, one of said plurality of detection modes including comparing a current transition matrix for a most recent sampling interval with the nominal set of data to determine if there is a substantial difference,
and if so, causing the processor to indicate that as intrusive or anomalous use of the computer program may have occurred.
<BR><BR>33.  The apparatus of claim 30, wherein the machine instructions further cause the processor to map the sequence of program modules that have been executed by the processor during each successive sampling interval into function sequences by
mapping program functionalities to the program modules, producing functional sequences for the successive sampling intervals, one of said plurality of detection modes including comparing current functional sequences for a most recent sampling interval
with the nominal set of data stored in the memory to determine if there is a substantial difference, and if so, causing the processor to indicate that an intrusive or anomalous use of the computer program may have occurred.
<BR><BR>34.  The apparatus of claim 30, wherein the machine instructions further cause the processor to: (a) access known intrusion profile data stored in the memory, which indicate activity occurring during different intrusive or anomalous uses of the
computer program;  (b) compare a current profile for a most recent sampling interval derived from the program module sequence data with the known intrusion profile data;  and (c) if the current profile substantially matches any of the known intrusion
profile data, positively determine that an intrusive or anomalous use of the computer program has occurred.
<BR><BR>35.  The apparatus of claim 30, further comprising a display, wherein the machine instructions further cause the processor to display an alarm on the display if it appears that an intrusive or anomalous use of the computer program has occurred.
<HR> <CENTER><b><i>Description</b></i></CENTER> <HR> <BR><BR>FIELD OF THE INVENTION
<BR><BR>The present invention generally relates to detecting the use of software, and more specifically, to the dynamic detection of an intrusive anomalous use of computer software.
<BR><BR>BACKGROUND OF THE INVENTION
<BR><BR>The literature and media abound with reports of successful violations of computer system security by both external attackers and internal users.  These breaches occur through physical attacks, social engineering attacks, and attacks on the system
software.  In a system software attack, the intruder subverts or bypasses the security mechanisms of the system in order to gain unauthorized access to the system or to increase current access privileges.  These attacks are successful when the attacker
is able to cause the system software to execute in a manner that is typically inconsistent with the software specification and thus leads to a breach in security.
<BR><BR>Intrusion detection systems monitor some traces of user activity to determine if an intrusion has occurred.  The traces of activity can be collated from audit trails or logs, network monitoring or a combination of both.  Once the data regarding a
relevant aspect of the behavior of the system are collected, the classification stage starts.  Intrusion detection classification techniques can be broadly catalogued in the two main groups: misuse intrusion detection, and anomaly intrusion detection. 
The first type of classification technique searches for occurrences of known attacks with a particular "signature," and the second type searches for a departure from normality.  Some of the newest intrusion detection tools incorporate both approaches.
<BR><BR>One prior art system for detecting an intrusion is the EMERALD.TM.  program.  EMERALD defines the architecture of independent monitors that are distributed about a network to detect intrusions.  Each monitor performs a signature or profile
analysis of a "target event stream" to detect intrusions and communicates such detection to other monitors on the system.  The analysis is performed on event logs, but the structure of the logs is not prescribed and the timeliness of the analysis and
detection of an intrusion depends on the analyzed system and how it chooses to provide such log data.  By monitoring these logs, EMERALD can thus determine that at some point in the event stream that was recorded in the log, an intrusion occurred. 
However, the detection is generally not implemented in real time, but instead occurs at some interval of time after the intrusion.  Also, this prior art system does not allow monitoring of all types of software activity, since it is limited to operating
system kernel events.  Accordingly, it would be desirable to provide a real time intrusion detection paradigm that is applicable to monitoring almost any type of program.
<BR><BR>It would be preferable to detect an intrusion based on the measurement of program activity as control is passed among program modules.  As a system executes its customary activities, the intrusion detection scheme should estimate a nominal system
behavior.  Departures from the nominal system profile will likely represent potential invidious activity on the system.  Since unwanted activity may be detected by comparison of the current system activity to that occurring during previous assaults on
the system, it would be desirable to store profiles for recognizing these activities from historical data.  Historical data, however, cannot be used to recognize new kinds of assaults.  An effective security tool would be one designed to recognize
assaults as they occur through the understanding and comparison of the current behavior against nominal system activity.  Currently, none of the prior art techniques fully achieve these objectives.
<BR><BR>SUMMARY OF THE INVENTION
<BR><BR>The present invention represents a new software engineering approach to intrusion detection using dynamic software measurement to assist in the detection of intruders.  Dynamic software measurement provides a framework to analyze the internal
behavior of a system as it executes and makes transitions among its various modules governed by the structure of a program call graph.  A target system is instrumented so that measurements can be obtained to profile the module activity on the system in
real time.  Essentially, this approach measures from the inside of a software system to make inferences as to what is occurring outside of the program environment.  In contrast, the more traditional approach of the prior art measures or profiles system
activity from system log files and other such patterns of externally observable behavior.
<BR><BR>Program modules are distinctly associated with certain functionalities that a program is capable of performing.  As each functionality is executed, it creates its own distinct signature of transition events.  Since the nominal behavior of a
system is more completely understood while it is executing its customary activities, this nominal system behavior can be profiled quite accurately.  Departures from a nominal system profile represent potential invidious activity on the system.  New
profiles of intrusive behavior can be stored and used to construct an historical database of intrusion profiles.  However, these historical data cannot be used as a basis for the recognition of new types of assaults.  The present invention is designed to
recognize assaults as they occur through the understanding and comparison of the current behavior against nominal system activity. <BR><BR>BRIEF DESCRIPTION OF THE DRAWING FIGURES
<BR><BR>The foregoing aspects and many of the attendant advantages of this invention will become more readily appreciated as the same becomes better understood by reference to the following detailed description, when taken in conjunction with the
accompanying drawings, wherein:
<BR><BR>FIG. 1 is a block diagram illustrating the relationship between instrumented program modules and a mapping module that generates a sequence of module streams;
<BR><BR>FIG. 2 is a block diagram illustrating the operation of a module sequence transducer of a first kind;
<BR><BR>FIG. 3 is a block diagram illustrating the operation of a module sequence transducer of a second kind;
<BR><BR>FIG. 4 is a block diagram illustrating the operation of a module sequence transducer of a third kind;
<BR><BR>FIG. 5 is a block diagram illustrating the operation of a comparator of a first kind;
<BR><BR>FIG. 6 is a block diagram illustrating the operation of a comparator of a second kind;
<BR><BR>FIG. 7 is a block diagram illustrating the operation of a comparator of a third kind;
<BR><BR>FIG. 8 is a block diagram illustrating an environment in which a preferred embodiment of the present invention operates;
<BR><BR>FIG. 9 is an isometric view of a generally conventional computer system suitable for implementing the present invention; and
<BR><BR>FIG. 10 is block diagram showing internal components of the computer system of FIG. 9. <BR><BR>DESCRIPTION OF THE PREFERRED EMBODIMENT
<BR><BR>Environment of the Present Invention
<BR><BR>A system operating in accord with the present invention has three modes of operation.  Each of these modes represents an incremental improvement in the ability of the system to detect an intrusion or abnormal use of the system or program
executing thereon.  However, as the resolving ability of the system increases, there is an associated penalty in processing overhead.  In a first mode, simple execution profiles indicative of modules that have executed are employed for the evaluation of
intrusive activity.  This mode is the most coarse grained level of operation for the detection of intrusions, but it has the least cost in terms of performance of the three modes.  In the second mode, transitions from one program module to the next are
recorded, providing a much finer grained description of program behavior.  This second mode is capable of detecting more subtle forms of attack and is also more costly to run in terms of the degradation of performance and consumption of computer memory. 
In a third mode, sequences of module transitions are mapped onto specific design specification elements, or functionalities.  This third mode of operation can detect the most subtle of all intrusions, again at a greater expense of computation time and
memory space.
<BR><BR>FIG. 1 illustrates the internal program environment of a program that has been suitably instrumented for anomaly and/or intrusion detection.  Each program module, M.sub.i, of a plurality of program modules 101 will have calls placed in it at each
entry point and before each return.  Control is passed to a mapping module 102 that records any transition into and out of a program module.  The mapping module transmits the module transitions to a module sequence buffer 103 that buffers these data
until they are requested from the external program environment.  All of structures 101-103 are encapsulated within the operating environment of a program to which the present invention is applied to detect anomalous behavior or an intrusion.
<BR><BR>FIG. 2 shows the operation of a first profile transducer 202.  It is the purpose of first profile transducer 202 to capture module sequence information 201 from the internally instrumented program environment.  At intervals determined by an
externally provided sampling engine 204, first profile transducer 201 interrogates module sequence buffer 103, requesting current profile information.  The profile information obtained from the module sequence buffer is a list of all modules that have
executed since the last interrogation, and the frequencies of their executions.  First profile transducer 202 normalizes each of the module frequencies by dividing them by the total number of module transitions that have occurred during the sampling
interval.  These execution profiles are transmitted to and retained by an execution profile buffer 203.
<BR><BR>FIG. 3 shows the operation of a second profile transducer 302.  Second profile transducer 302 captures module sequence information 301 from the internal instrumented program environment.  At intervals determined by an externally provided sampling
engine 304, which is substantially different than the interval determined by sampling engine 204, the second profile transducer interrogates module sequence buffer 103 for current profile information.  The profile information requested from the module
sequence buffer is the list of all modules that have executed since the last interrogation and the frequencies of their executions.  Second profile transducer 302 develops a transition matrix for the current sampling interval.  This transition matrix is
an n.times.n matrix, where the entry in the i.sup.th row and the j.sup.th column is the frequency with which module i has transferred control to module j during the current sampling interval.  The transition matrix is transmitted to and retained by a
transition matrix buffer 303.
<BR><BR>FIG. 4 shows the operation of the third profile transducer.  It is the purpose of a third profile transducer 402 to capture module sequence information 401 from the internal instrumented program environment.  At intervals determined by an
externally provided sampling engine 404, the third profile transducer interrogates module sequence buffer 103 for current profile information.  The profile information requested from the module sequence buffer is the list of all modules that have
executed since the last interrogation and the frequency with which each module has executed during that interval.  Third profile transducer 402 maps the sequence of module transitions representing subtrees on a program call graph into function sequences
through the mapping of program functionalities to modules.  These functional sequences are transmitted to and retained by a functional sequences buffer 403.
<BR><BR>FIG. 5 shows the operation of an execution profile comparator 502.  The execution profile comparator determines any difference (i.e., a differenced profile) between a current execution profile 501 most recently obtained from first profile
transducer 202 and a nominal execution profile obtained from nominal profiles data 506, which represents the steady-state behavior of the software system with no intrusive activity.  The nominal profiles data are initially established by a calibration
process that is implemented by running the program in a calibration mode in which the program is run through as many of the functions and operations performed during a nominal operational phase.  A nominal activity profile and boundary conditions for
variations during this nominal operational phase are accumulated during this calibration mode.  The nominal profile is subsequently modified by a user (or administrator), if during normal operation of the program an alarm is raised, but it is determined
that no intrusion has occurred.  In a typical software application, there may be a wide range of behavior that is considered nominal.  The computational result of the comparison between the current execution profile and the steady state behavior of the
system represented by the nominal profile suite is used in two different subsystems.  First, if the total variance in the steady state profile rises above a pre-established threshold, then the recognition of an intrusive event becomes difficult.  In this
case, the comparator will increase the sampling rate set by the sample rate engine.  Similarly, the sampling rate may be decreased when the system is operating in a more quiescent mode to lessen the impact of the detection process on the total system
operation.  Second, the differenced profile is analyzed to determine if it has crossed a predetermined threshold level that represents an unacceptable departure from the nominal system behavior.  If so, then there is a potential new behavior on the
system and a level 1 alarm 503 is raised.  The system then attempts to match the differenced profile with known intrusion profiles data 505.  If a match for the differenced profile is found in the intrusion profile data, then a level 2 alarm 503 is
raised, indicating a certainty of an intrusive attack.
<BR><BR>FIG. 6 illustrates operation of a transition matrix comparator 602.  The transition matrix comparator determines any difference (i.e., a "differenced matrix") between a current transition matrix 601 that was most recently obtained from second
profile transducer 302 and a nominal transition matrix obtained from nominal transitions data 607 representing the steady-state behavior of the software system with no intrusive activity.  The result of the comparison between the current transition
matrix and the steady state behavior of the system represented by the nominal transitions suite is used in two different subsystems.  First, if the total variance in the steady state profile rises above a predefined threshold, the comparator will
increase the sample rate determined by a sample rate engine 606.  Similarly, the sampling rate may be decreased when the system is operating in a more quiescent mode to lessen the impact of the detection process on the total system operation.  Second,
the differenced matrix is analyzed to see whether it has crossed a predetermined threshold level that represents an unacceptable departure from the nominal system behavior.  If so, then there is a potential new behavior on the system and a level 1 alarm
603 will be raised.  Against this potential intrusive behavior, a static call tree 605 structure is stored in a single transition matrix.  Embedded in this static call tree structure is a set of legitimate module transitions.  A potentially new intrusive
behavior may be characterized by abnormal transitions in current transition matrix 601.  The system attempts to match the differenced matrix with known intrusion characteristics stored as sequences of characteristic transition matrix data 604.  If a
match for the differenced matrix is found in the intrusion transitions data, then a level 2 alarm 603 is raised, indicating a certainty of an intrusive attack.
<BR><BR>FIG. 7 shows the operation of a functional profile comparator 702, which behaves similar to execution profile comparator 502.  The fundamental difference between these two comparators is that functional profile comparator 702 operates on
functional profiles as opposed to execution profiles.  Functional profile comparator 702 determines any difference ("a differenced profile") between a most recent functional sequence 701 obtained from third profile transducer 402 and a nominal functional
profile obtained from nominal functional profiles data 706, which represents the steady-state behavior of the software system with no intrusive activity.  The result of the comparison between the most recent functional sequences and the steady state
behavior of the system represented by the nominal functional profile suite is again used in two different subsystems.  First, if the total variance in the steady state profile rises above a predefined threshold, the comparator will increase the sample
rate determined by a sample rate engine 705.  Similarly, the sampling rate may be decreased when the system is operating in a more quiescent mode to lessen the impact of the detection process on the total system operation.  Second, the differenced
profile will be analyzed to see whether it has crossed a predetermined threshold level that represents an unacceptable departure from the nominal system behavior.  In this event, there is a potential new behavior on the system, and a level 1 alarm 703
will be raised.  The system then attempts to match this differenced profile with a known intrusion profile from known intrusion profiles data 704.  If a match for the differenced profile is found in the intrusion profiles data then a level 2 alarm 703
will be raised, indicating a certainty of an intrusive attack.
<BR><BR>FIG. 8 shows the relationship among the various components of the <B><I>intrusion detection system</I></B>.  A transducer 802 and a comparator 803 are the essential functional components of the intrusion detection methodology.  The transducer obtains signals
from an instrumented software system 801 and computes activity measures for these signals.  The actual software signals may be obtained either from instrumented code (software probes) or directly from a hardware address bus (a hardware probe).  The
inputs to the transducer are software module entry and exit events that may be obtained either from software or hardware instrumentation.
<BR><BR>Depending on the level of resolution desired, the transducer will produce from the module transition events a summary profile of the execution transitions (execution profile), a transition matrix representing the frequency of transition events
from one module to another, or a function sequence of program activity.  The transducer interacts with the software system in real-time.  That is, all transition events are available to the transducer as they occur.
<BR><BR>The output of transducer 802 is sent directly to comparator 803 for analysis.  The rate at which these data are obtained is controlled by the comparator.  During periods of relatively light computational activity when there is little likelihood
of an intrusion, the sampling interval might be set to be relatively long.  Alternatively, during periods of extensive system activity, the sampling frequency can be increased to provide increased resolution on system activity.  All sampling activity is
measured in system epochs, or module transitions.  The sampling rate 810 is controlled by the sample rate engine (not separately shown) associated with the comparator.
<BR><BR>Each activity measure 808 is obtained from transducer 802 by comparator 803.  The comparator makes a formal assessment as to whether the current system activity is non-threatening (nominal) or otherwise.  There are essentially two types of
non-nominal activity.  The first occurs as new users or new programs are being run on the system.  This new activity is reviewed by an external decision maker, such as the system administrator, and if determined to be non-threatening by that person, is
added to the system repertoire of nominal behavior in an intrusion database 805.  However, the observed activity may represent an intrusion event.  There are two types of intrusion events.  First, there are existing or known intrusion events.  These have
well-known and established intrusion profiles that are stored in intrusion database 805.  Comparator 803 will search intrusion database 805 for a matching profile, and if it finds a matching profile, will raise a level 2 alarm 807.  A level 2 alarm means
that there is a high level of certainty that an intrusion event is in progress.  If, on the other hand, the intrusion event is not found in intrusion database 805, comparator 803 will raise a level 1 alarm 807, indicating that new behavior has been
observed on the system.  Typically, the level 1 alarm system would be referred to a system administrator and/or an artificial intelligence (AI) engine for review.
<BR><BR>The ability to recognize an actual intrusion event is dependent on the variance in the profiles of software activity.  This variation may be controlled by varying the sampling rate of the instrumented software.  The sampling rate is controlled by
a sensitivity adjustment 804, which can be designed into the software and/or controlled by input from the system administrator.
<BR><BR>To enhance the overall viability of the system to detect new and unobserved intrusion events, a visualizer 806 may optionally be added to the system.  This visualizer receives a data stream 809 from the comparator and graphically displays module
transition information in a continuous recording strip on a display terminal (not separately shown).  The moving image of system activity closely resembles a side-scan sonar display.  Module (or functionality) frequency data are displayed to render a
visual image of overall system activity.  Human pattern recognition ability currently greatly surpasses that of any available software.  The visualizer provides a real-time image of system activity from which abnormal activity may be detected by a system
administrator using this superior pattern recognition capability.
<BR><BR>A Profile-oriented Anomaly Detection Model
<BR><BR>As any software system is being specified, designed and developed, it is constructed to perform a distinct set of mutually exclusive operations O for the customer.  An example of such an operation might be the activity of adding a new user to a
computer system.  At the software level, these operations must be reduced to a well defined set of functions F. These functions represent the decomposition of operations into sub-problems that may be implemented on computer systems.  The operation of
adding a new user to the system might involve the functional activities of changing from the current directory to a password file, updating the password file, establishing user authorizations, and creating a new file for the new user.  During the
software design process, the basic functions are mapped by system designers to specific software program modules that implement the functionality.
<BR><BR>From the standpoint of computer security, not all operations are equal.  Some user operations may have little or no impact on computer security considerations.  Other operations, such as system maintenance activities, have a much greater impact
on security.  System maintenance activities being performed by system administrators would be considered nominal system behavior.  System maintenance activities being performed by dial-up users, on the other hand, would not be considered nominal system
behavior.  In order to implement this decomposition process, a formal description of these relationships must be established.  To assist in the subsequent discussion of program functionality, it will be useful to make this description somewhat more
precise by introducing some notation conveniences.
<BR><BR>Formal Description of Software Operation
<BR><BR>Assume that a software system S was designed to implement a specific set of mutually exclusive functionalities F. Thus, if the system is executing a function .function..epsilon.F, then it cannot be expressing elements of any other functionality
in F. Each of these functions in F was designed to implement a set of software specifications based on a user's requirements.  From a user's perspective, this software system will implement a specific set of operations O. This mapping from the set of
user perceived operations O to a set of specific program functionalities is one of the major functions in the software specification process.  It is possible, then, to define a relation IMPLEMENTS over O.times.F such that IMPLEMENTS(o, .function.) is
true if functionality .function.  f is used in the specification of an operation o.
<BR><BR>From a computer security standpoint, operations can be envisioned as the set of services available to a user (e.g., login, open a file, write to a device), and functionalities as the set of internal operations that implement a particular
operation (e.g., user-id validation, access control list (ACL) lookup, labeling).  When viewed from this perspective, it is apparent that user operations, which may appear to be non-security relevant, may actually be implemented with security relevant
functionalities (send mail is a classic example of this, an inoffensive operation of send mail can be transformed into an attack, if the functionalities that deal with buffers are thereby overloaded).
<BR><BR>The software design process is strictly a matter of assigning functionalities in F to specific program modules m.epsilon.M, the set of program modules of system S. The design process may be thought of as the process of defining a set of relations
ASSIGNS over F.times.M, such that ASSIGNS(.function., m) is true if functionality .function.  is expressed in module m. For a given software system S, let M denote the set of all program modules for that system.  For each function .function..epsilon.F,
there is a relation p over F.times.M such that p(.function., m) is the proportion of execution events of module m when the system is executing function .function..
<BR><BR>Each operation that a system may perform for a user may be thought of as having been implemented in a set of functional specifications.  There may be a one-to-one mapping between the user's notion of an operation and a program function.  In most
cases, however, there may be several discrete functions that must be executed to express the user's concept of an operation.  For each operation o that the system may perform, the range of functionalities .function.  must be well known.  Within each
operation, one or more of the system's functionalities will be expressed.
<BR><BR>The Software Epoch
<BR><BR>When a program is executing a functionality, it apportions its activities among a set of modules.  As such, it transitions from one module to the next on a call (or return) sequence.  Each module called in this call sequence will have an
associated call frequency.  When the software is subjected to a series of unique and distinct functional expressions, there is a different behavior for each of the user's operations, in that each will implement a different set of functions, which, in
turn, invoke possibly different sets of program modules.
<BR><BR>An epoch begins with the onset of execution in a particular module and ends when control is passed to another module.  The measurable event for modeling purposes is this transition among the program modules.  Calls from a module are accumulated,
along with returns to that module, to produce a total count.  Each of these transitions to a different program module from the one currently executing represents an incremental change in the epoch number.  Computer programs executing in their normal mode
make state transitions between program modules rather rapidly.  In terms of real clock time, many epochs may elapse in a relatively short period.
<BR><BR>Formal Definitions of Profiles
<BR><BR>It can be seen that there is a distinct relationship between any given operation o and a given set of program modules.  That is, if the user performs a particular operation, then this operation manifests itself in certain modules receiving
control.  It is also possible to detect, inversely, which program operations are being executed by observing the pattern of modules executing, i.e., the module profile.  In a sense then, the mapping of operations to modules and the mapping of modules to
operations is reflexive.
<BR><BR>It is a most unfortunate accident of most software design efforts that there are really two distinct set of operations.  On the one hand, there is a set of explicit operations O.sub.E.  These are the intended operations that appear in the
Software Requirements Specification documents.  On the other hand, there is also a set of implicit operations O.sub.I that represents unadvertised features of the software, which have been implemented through designer carelessness or ignorance.  These
implicit operations are neither documented nor well known except by a group of knowledgeable and/or patient system specialists, called hackers.
<BR><BR>Since the set of implicit operations O.sub.I is not well known for most systems, most system administrators are obliged to learn about implicit operations by carefully investigating program behavior, or by experiencing the unfortunate results of
an intrusion by someone who has learned about these operations.  Hackers and other interested citizens will find implicit operations and exploit them.  What is known is the set of operations O.sub.E and the mappings of the operations onto the set of
modules M. For each of the explicit operations there is an associated module profile.  That is, if an explicit operation is executed, then a well-defined set of modules will execute in a very predictable fashion.  This fact may be exploited to develop a
reasonable profile of the system when it is executing operations from the set of explicit operations.  This nominal system behavior serves as a stable reference against which intrusive activity may be measured.  That is, when an observation is made of
module profiles that is not representative of the operations in O.sub.E, an assumption may be made that the new observation is one or more operations from the set O.sub.I ; in other words, there is an intruder present.
<BR><BR>When the process of software requirements specification is complete, a system consisting of a set of a mutually exclusive operations will have been defined.  Characteristically, each user of a new system will cause each operation to be performed
at a potentially different rate than another user.  Each user, then, will induce a probability distribution on the set O of mutually exclusive operations.  This probability function is a multinomial distribution and constitutes the operational profile
for that user.
<BR><BR>The operational profile of a software system is the set of unconditional probabilities of each of the operations in O being executed by the user.  Then, Pr[X=k], k=1, 2, .  . . , .parallel.O.parallel.  is the probability that the user is
executing program operation k as specified in the functional requirements of the program and .parallel.O.parallel.  is the cardinality of the set of operations.  A program executing on a serial machine can only be executing one operation at a time.  The
distribution of the operational profile is thus multinomial for programs designed to fulfill more than two distinct operations.
<BR><BR>A user performing the various operations on a system causes each operation to occur in a series of steps or transitions.  The transition from one operation to another may be described as a stochastic process.  In this case, an indexed collection
of random variables {X.sub.t } may be defined, where the index t runs through a set of non-negative integers t=0, 1, 2, .  . . representing the individual transitions or intervals of the process.  At any particular interval, the user is found to be
expressing exactly one of the system's a operations.  The fact of the execution occurring in a particular operation is a state of the user.  During any interval, the user is found performing exactly one of a finite number of mutually exclusive and
exhaustive states that may be labeled 0, 1, 2, .  . . a. In this representation of the system, there is a stochastic process {X.sub.t }, where the random variables are observed at intervals t=1, 2, .  . . and where each random variable may take on any
one of the (a+1) integers, from the state space O={0, 1, 2, .  . . , a}.
<BR><BR>Each user may potentially bring his/her own distinct behavior to the system.  Thus, each user will have a unique characteristic operational profile.  It is a characteristic, then, of each user to induce a probability function p.sub.i =Pr[X=i] on
the set of operations O. In that these operations are mutually exclusive, the induced probability function is a multinomial distribution.
<BR><BR>As the system progresses through the steps in the software lifecycle, the user requirements specifications, the set O must be mapped on a specific set of functionalities F by systems designers.  This set F is in fact the design specifications for
the system.  As per the earlier discussion, each operation is implemented by one for more functionalities.  The transition from one functionality to another may be also described as a stochastic process.  Thus, a new indexed collection of random
variables {Y.sub.t } may be defined, representing the individual transitions events among particular functionalities.  At any particular interval, a given operation expresses exactly one of the system's b+1 functionalities.  During any interval, the user
is found performing exactly one of a finite number of mutually exclusive and exhaustive states that may be labeled 0, 1, 2, .  . . , b. In this representation of the system, there is a stochastic process {Y.sub.t }, where the random variables are
observed at intervals t=0, 1, 2, .  . . and where each random variable may take on any one of the (b+1) integers, from the state space F={0, 1, 2, .  . . , b}.
<BR><BR>When a program is executing a given operation, say o.sub.k, it will distribute its activity across the set of functionalities F.sup.(o.sup..sub.k .sup.).  At any arbitrary interval, n, during the expression of o.sub.k, the program will be
executing a functionality .function..sub.i.epsilon.F.sup.(o.sup..sub.k .sup.) with a probability, Pr[Y.sub.n =i.vertline.X=k].  From this conditional probability distribution for all operations, the functional profile for the design specifications may be
derived as a function of a user operational profile, as:
<BR><BR>Alternatively:
<BR><BR>The next logical step is to study the behavior of a software system at the module level.  Each of the functionalities is implemented in one or more program modules.  The transition from one module to another may be also described as a stochastic
process.  Therefore, a third indexed collection of random variables {Z.sub.t } may be defined, as before, representing the individual transitions events among the set of program modules.  At any particular interval, a given functionality is found to be
executing exactly one of the system's c modules.  The fact of the execution occurring in a particular module is a state of the system.  During any interval, the system is found executing exactly one of a finite number of mutually exclusive and exhaustive
states (program modules) that may be labeled 0, 1, 2, .  . . , c. In this representation of the system, there is a stochastic process {Z.sub.t }, where the random variables are observed at epochs t=0, 1, 2, .  . . and where each random variable may take
on any one of the (c+1) integers, from the state space M={0, 1, 2, .  . . , c}.
<BR><BR>Each functionality j has a distinct set of modules M.sub..function..sub..sub.j that it may cause to execute.  At any arbitrary interval n during the expression of .function..sub.j, the program will be executing a module
m.sub.i.epsilon.M.sub..function..sub..sub.j with a probability Pr[Z.sub.n =i.vertline.Y=j].  From this condition probability distribution for all functionalities, the module profile for the system may be derived as a function of the system functional
profile as follows:
<BR><BR>Again,
<BR><BR>The module profile r ultimately depends on the operational profile p as can be seen by substituting for w.sub.j in the equation above.
<BR><BR>Each distinct operational scenario creates its own distinct module profile.  It is this fact that is exploited in the detection of unwanted or intrusive events in the present invention.
<BR><BR>Point Estimates for Profiles
<BR><BR>The focus will now shift to the problem of developing point estimates for the probabilities for various profiles.  These profiles were recognized in terms of their multinomial nature.  The multinomial distribution is useful for representing the
outcome of an experiment involving a set of mutually exclusive events.  Let ##EQU1##
<BR><BR>where S.sub.i is one of M mutually exclusive sets of events.  Each of these events would correspond to a program executing a particular module in the total set of program modules.  Further, let Pr(S.sub.i)=w.sub.i and:
<BR><BR>under the condition that T=M+1, as defined earlier.  Accordingly, w.sub.i is the probability that the outcome of a random experiment is an element of the set S.sub.i.  If this experiment is conducted over a period of n trials, then the random
variable X.sub.i will represent the frequency of S.sub.i outcomes.  In this case, the value n represents the number of transitions from one program module to the next.  Note that:
<BR><BR>This particular distribution will be useful in the modeling of a program with a set of k modules.  During a set of n program steps, each of the modules may be executed.  These, of course, are mutually exclusive events.  If module i is executing,
then module j cannot be executing.
<BR><BR>The multinomial distribution function with parameters n and w=(w.sub.1, w.sub.2, .  . . , w.sub.T) is given by: ##EQU2##
<BR><BR>where x.sub.i represents the frequency of execution of the i.sup.th program module.  The expected values for x.sub.i are given by:
<BR><BR>the variances by:
<BR><BR>and the covariance by:
<BR><BR>It now becomes necessary to understand the precise multinomial distribution of a program's execution profile while it is executing a particular functionality.  The problem is that every time a program is run, there will be some variation in the
profile from one execution sample to the next.  It will be difficult to estimate the parameters w=(w.sub.1, w.sub.2, .  . . , w.sub.T) for the multinomial distribution of the execution profile.  Rather than estimating these parameters statically, it is
far more useful to get estimates of these parameters dynamically as the program is actually in operation, hence the utility of the Bayesian approach.
<BR><BR>To aid in the process of characterizing the nature of the true underlying multinomial distribution, observe that the family of Dirichlet distributions is a conjugate family for observations that have a multinomial distribution.  The probability
density function for a Dirichlet distribution, D(.alpha., .alpha..sub.T), with a parametric vector .alpha.=(.alpha..sub.1, .alpha..sub.2, .  . . , .alpha..sub.k-1) where (.alpha..sub.i &gt;0; i=1, 2, .  . . , k-1) is: ##EQU3##
<BR><BR>where (w.sub.i &gt;0; i=1, 2, .  . . , M) and ##EQU4##
<BR><BR>The expected values of the w.sub.i are given by ##EQU5##
<BR><BR>where .alpha..sub.0 =.SIGMA..sub.i=1.sup.T.alpha..sub.i.  In this context, .alpha..sub.0 represents the total epochs.  The variance of the w.sub.i is given by: ##EQU6##
<BR><BR>and the covariance by: ##EQU7##
<BR><BR>The value of the use of the Dirichlet conjugate family for modeling purposes is twofold.  First, it permits the probabilities of the module transitions to be estimated directly from the observed transitions.  Secondly, it is possible to obtain
revised estimates for these probabilities as the observation process progresses.  Now consider the behavior of a software system whose execution profile has a multinomial distribution with parameters n and W=(w.sub.1, w.sub.2, .  . . , w.sub.k-1) where n
is the total number of observed module transitions and the values of the w.sub.1 are unknown.  It is assumed that the prior distribution of W is a Dirichlet distribution with a parametric vector .alpha.=(.alpha..sub.1, .alpha..sub.2, .  . . ,
.alpha..sub.k-1) where (.alpha..sub.i &gt;0; i=1, 2, .  . . , k-1).  Then the posterior distribution of W for the behavioral observation X=(x.sub.i, x.sub.2, .  . . , x.sub.k-1) is a Dirichlet distribution with parametric vector .alpha.*=(.alpha..sub.1
+x.sub.1, .alpha..sub.2 +x.sub.2, .  . . , .alpha..sub.k-1 +x.sub.k-1).  As an example, consider the behavior of a large software system with such a parametric vector.  As the system makes sequential transitions from one module to another, the posterior
distribution of W at each transition will be a Dirichlet distribution.  Further, for i=1, 2, .  . . T, the i.sup.th component of the augmented parametric vector .alpha.  will be increased by 1 unit each time module m.sub.i is executed.
<BR><BR>Recognizing Abnormalities
<BR><BR>Program modules are bound together by a call graph whose structure is described by the CALL relation over M.times.M.  From this call graph, a probability adjacency matrix P may be constructed whose entries represent the transition probabilities
from each module to another module at each epoch in the execution process.  Thus, the element p.sub.ij.sup.(n) of this matrix on the n.sup.th epoch are the probabilities that CALL(m.sub.i, m.sub.j) is true for that epoch.
<BR><BR>As a program executes an operation, it makes many module transitions.  However, this process is not random.  The order in which modules may be executed is determined by the call graph of a program.  As a program executes, it transitions from one
module to another in a sequence of module calls and returns.  A sequence is thus an ordered set of events from a continuous event stream.  It is possible, for example, to obtain from a software system during execution a sequence of module execution
events represented by &lt;m.sub..alpha..sub..sub.1 , m.sub..alpha..sub..sub.2 , m.sub..alpha..sub..sub.3 , m.sub..alpha..sub..sub.4 , m.sub..alpha..sub..sub.5 , .  . . &gt;, where m.sub..alpha..sub..sub.i represents the execution of a module.  A
sequential pair of elements (vis.  &lt;m.sub..alpha..sub..sub.1 , m.sub..alpha..sub..sub.2 &gt;) from this sequence represents a transition.  From a nomenclature standpoint, let t.sub..alpha..sub..sub.1 .sub..alpha..sub..sub.2
=&lt;m.sub..alpha..sub..sub.1 , m.sub..alpha..sub..sub.2 &gt; represent the transition from component m.sub..alpha..sub..sub.1 to component m.sub..alpha..sub..sub.2 .  For each of these transition events that occur within the nominal operation of the
system, this transition is recorded in an event transition matrix E for the system.  This event transition matrix is a square matrix with dimensionality equal to the number of modules in the system.  For each epoch, there will be exactly one transition. 
If the matrix E.sup.(n) represents the event transition matrix on the n.sup.th epoch, then E.sup.(n) may be derived from E.sup.(n-1) by the change in one element e.sub..alpha..sub..sub.1 .sub..alpha..sub..sub.2 .sup.(n) =e.sub..alpha..sub..sub.1
.sub..alpha..sub..sub.2 .sup.(n-1) +1 for the transition t.sub..alpha..sub..sub.1 .sub..alpha..sub..sub.2 .  ##EQU8##
<BR><BR>The steady state event activity for each event in the system is represented by one row in the matrix ##EQU9##
<BR><BR>Let ##EQU10##
<BR><BR>represent the row marginal for the j.sup.th module and ##EQU11##
<BR><BR>Point estimates for the module transition profiles p.sub.j =&lt;p.sub.1j, p.sub.1j, .  . . p.sub.1j &gt; for each system event may be derived from the steady state system activity matrix by Equation (1) as follows: p.sub.ij =m.sub.ij
/m.sub..cndot.j.  Further, point estimates for the execution profiles may be derived as follows: p.sub.i =m.sub.i /m.sub..cndot..
<BR><BR>The real question now is whether a new sequence m'=&lt;m'.sub..alpha..sub..sub.1 , m'.sub..alpha..sub..sub.2 , m'.sub..alpha..sub..sub.3 , m'.sub..alpha..sub..sub.4 , m'.sub..alpha..sub..sub.5 , .  . . &gt; of observed system activity is really
equivalent to the steady state system activity or whether this is new (aberrant) behavior on the part of some user of the system.  If, in fact, the new sequence m' is typical of system behavior, then there should be no essential differences between the
expected distribution of m' and the actual sequence.
<BR><BR>Let the sequence m' of b elements represent the activity of the n program modules during a particular interval.  From this sequence, a new matrix E.sup.(b) may be derived whose elements are determined in the same manner as matrix M, except for
the fact that they only represent the activity of the system during the interval of k observations of the sequence m'. Let ##EQU12##
<BR><BR>represent the row marginal, as above, for the j.sup.th event in the new sequence.
<BR><BR>The real question is whether the new sequence m' is drawn from the same population of the nominal behavior represented by the matrix M, or whether it represents abnormal behavior.  This conjecture may be tested directly from: ##EQU13##
<BR><BR>where p.sub.n =1-p.sub.1 - .  . . p.sub.n-1 and .chi..sub..gamma..sup.2 is the 100 .gamma.% point of the Chi-square distribution with n-1 degrees of freedom.
<BR><BR>In summary, when a user is exercising a system, the software will be driven through a sequence of transitions from one module to the next, S=&lt;m.sub.ab, m.sub.bc, m.sub.cd, .  . . &gt;, where m.sub.ab represents a transition from module a to
module b. Over a fixed number of epochs, each progressive sequence will exhibit a particular execution profile.  It represents a sample drawn from a pool of nominal system behavior.  Thus, the series of sequences S=&lt;S.sub.i, S.sub.i+1, S.sub.i+2, .  .
. &gt; above will generate a family of execution profiles &lt;P.sub.i, P.sub.i+1, P.sub.i+2, .  . . &gt;.  What becomes clear after a period of observation is that the range of behavior exhibited by a system and expressed in sequences of execution
profiles is highly constrained.  There are certain standard behaviors that are demonstrated by the system during its normal operation.  The activities of an intruder will create significant disturbances in the nominal system behavior.
<BR><BR>The whole notion of intrusion detection would be greatly facilitated if the functionalities of the system were known and well defined.  It would also be very convenient if there were a precise description of the set of operations for the
software.  Indeed, if these elements of software behavior were known and precisely specified, the likelihood of security leaks in the system would diminish greatly.  In the absence of these specifications, it will be assumed that neither the operational
profiles nor the functional profiles can be observed directly.  Instead, the distribution of activity among the program modules must be observed in order to make inferences about the behavior of the system.
<BR><BR>The present invention, then, represents a new real-time approach to detect aberrant modes of system behavior induced by abnormal and unauthorized system activities.  Within the category of aberrant behavior, there are two distinct types of
problems.  First, a user may be executing a legitimate system operation (technically an operation o.epsilon.O.sub.E) for which he is not authorized.  Second, a user (hacker) could be exploiting his knowledge of the implicit operations of the system by
executing an operation o.epsilon.O.sub.I.  Each of these two different types of activities will create a distinct and observable change in the state of the software system and its nominal activity.  Violations in the security of the system will result in
behavior that is outside the normal activity of the system and thus result in a perturbation in the normal profiles.  These violations are detected by the analysis of the profiles generated from an instrumented software system against of set of known
intrusion profiles.
<BR><BR>It is important to note that the present invention is broadly applicable to almost any type of software and can monitor activity occurring in any application or operating system to detect anomalies indicative of intrusive behavior.  Prior art
intrusion detection systems generally monitor events from the outside in and thus, can overlook an intrusion because they do not respond to variations in software internal activity that is not logged.  In contrast, the present invention operates in real
time, from within the application being monitored, and is able to respond to subtle changes that occur as a result of an intrusion.  Furthermore, since the present invention can be applied to any type of computational activity, it can be used to monitor
almost any type of software system and detect intrusions, for example, in software running a web server, or in database management systems, or operating system shells, or file management systems.  Any software that may impacted by deliberate misuse may
be instrumented and monitored with the present invention to detect such misuse or intrusion.
<BR><BR>Computer System Suitable for Implementing the Present Invention
<BR><BR>With reference to FIG. 9, a generally conventional computer 930 is illustrated, which is suitable for use in connection with practicing the present invention.  Alternatively, a workstation, laptop, distributed systems environment, or other type
of computational system may instead be used.  Computer 930 includes a processor chassis 932 in which are optionally mounted a floppy or other removable media disk drive 934, a hard drive 936, a motherboard populated with appropriate integrated circuits
(not shown), and a <B><I>power</I></B> supply (also not shown).  A monitor 938 (or other display device) is included for displaying graphics and text generated by software programs, and more specifically, for alarm levels of the present invention.  A mouse 940 (or
other pointing device) is connected to a serial port (or to a bus port) on the rear of processor chassis 932, and signals from mouse 940 are conveyed to the motherboard to control a cursor on the display and to select text, menu options, and graphic
components displayed on monitor 938 in response to software programs executing on the computer, including any program implementing the present invention.  In addition, a keyboard 943 is coupled to the motherboard for entry of text and commands that
affect the running of software programs executing on the computer.
<BR><BR>Computer 930 also optionally includes a compact disk-read only memory (CD-ROM) drive 947 into which a CD-ROM disk may be inserted so that executable files and data on the disk can be read for transfer into the memory and/or into storage on hard
drive 936 of computer 930.  Other types of data storage devices (not shown), such as a DVD drive or other optical/magnetic media drive, may be included in addition to, or as an alternative to the CD-ROM drive.  Computer 930 is preferably coupled to a
local area and/or wide area network and is one of a plurality of such computers on the network.
<BR><BR>Although details relating to all of the components mounted on the motherboard or otherwise installed inside processor chassis 932 are not illustrated, FIG. 10 is a block diagram illustrating some of the functional components that are included. 
The motherboard includes a data bus 933 to which these functional components are electrically connected.  A display interface 935, comprising a video card, for example, generates signals in response to instructions executed by a central processing unit
(CPU) 953 that are transmitted to monitor 938 so that graphics and text are displayed on the monitor.  A hard drive/floppy drive interface 937 is coupled to data bus 933 to enable bi-directional flow of data and instructions between data bus 933 and
floppy drive 934 or hard drive 936.  Software programs executed by CPU 953 are typically stored on either hard drive 936, or on a CD-ROM, DVD, other optical/magnetic high capacity storage media, or a floppy disk (not shown).  Alternatively, the programs
may be stored on a server, e.g., if the computer comprises a workstation.  A software program including machine language instructions that cause the CPU to implement the present invention will likely be distributed either on conventional magnetic storage
media, on-line via, or on a CD-ROM or other optical/magnetic media.
<BR><BR>A serial/mouse port 939 (representative of the two serial ports typically provided) is also bi-directionally coupled to data bus 933, enabling signals developed by mouse 940 to be conveyed through the data bus to CPU 953.  A CD-ROM interface 959
connects CD-ROM drive 947 (or other storage device) to data bus 933.  The CD-ROM interface may be a small computer systems interface (SCSI) type interface or other interface appropriate for connection to and operation of CD-ROM drive 947.
<BR><BR>A keyboard interface 945 receives signals from keyboard 943, coupling the signals to data bus 933 for transmission to CPU 953.  Optionally coupled to data bus 933 is a network interface 950 (which may comprise, for example, an Ethernet.TM.  card
for coupling the computer to a local area and/or wide area network).  Thus, data used in connection with the present invention may optionally be stored on a remote server and transferred to computer 930 over the network to implement the present
invention.
<BR><BR>When a software program is executed by CPU 953, the machine instructions comprising the program that are stored on removable media, such as a CD-ROM, a server (not shown), or on hard drive 936 are transferred into a memory 951 via data bus 933. 
Machine instructions comprising the software program are executed by CPU 953, causing it to implement functions as described above while running a computer program.  Memory 951 includes both a nonvolatile read only memory (ROM) in which machine
instructions used for booting up computer 930 are stored, and a random access memory.  (RAM) in which machine instructions and data are temporarily stored when executing application programs, such as a database program using the present invention.
<BR><BR>Although the present invention has been described in connection with the preferred form of practicing it and modifications to that preferred form, those of ordinary skill in the art will understand that many other modifications can be made
thereto within the scope of the claims that follow.  Accordingly, it is not intended that the scope of the invention in any way be limited by the above description, but instead be determined entirely by reference to the claims that follow.
<BR><BR><CENTER><b>* * * * *</b></CENTER>
<HR>
   <CENTER>
   <a href=http://pdfpiw.uspto.gov/.piw?Docid=06681331&homeurl=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO2%2526Sect2%3DHITOFF%2526u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%2526r%3D1024%2526f%3DG%2526l%3D50%2526d%3DPTXT%2526s1%3D((G06F.CPCL.%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522))%252BAND%252B((power%252BOR%252Belectricity)%252BOR%252Brelay))%2526p%3D21%2526OS%3DCPCL%2FG06F%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522)%252BAND%252B(power%252Bor%252Belectricity%252Bor%252Brelay)%2526RS%3D((CPCL%2FG06F%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522))%252BAND%252B((power%252BOR%252Belectricity)%252BOR%252Brelay))&PageNum=&Rtype=&SectionNum=&idkey=NONE&Input=View+first+page><img src="/netaicon/PTO/image.gif" alt="[Image]" border="0" valign="middle"></A>
   <TABLE>
   <TR><TD align="center"><A href="https://certifiedcopycenter.uspto.gov/other/patft/view.html?backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D1024%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3D((G06F.CPCL.%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522))%252BAND%252B((power%252BOR%252Belectricity)%252BOR%252Brelay))%26p%3D21%26OS%3DCPCL%2FG06F%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522)%252BAND%252B(power%252Bor%252Belectricity%252Bor%252Brelay)&backLabel1=Back%20to%20Document%3A%206681331"><IMG border="0" src="/netaicon/PTO/cart.gif" border="0" valign="m
iddle" alt="[View Shopping Cart]"></A>
   <A href="https://certifiedcopycenter.uspto.gov/other/patft/order.html?docNumber=6681331&backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D1024%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3D((G06F.CPCL.%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522))%252BAND%252B((power%252BOR%252Belectricity)%252BOR%252Brelay))%26p%3D21%26OS%3DCPCL%2FG06F%252BAND%252B(%252522intrusion%252Bprevention%252Bsystem%252522%252BOR%252B%252522intrusion%252Bdetection%252Bsystem%252522)%252BAND%252B(power%252Bor%252Belectricity%252Bor%252Brelay)&backLabel1=Back%20to%20Document%3A%206681331">
   <IMG border="0" src="/netaicon/PTO/order.gif" valign="middle" alt="[Add to Shopping Cart]"></A>
   </TD></TR>
   <TR><TD align="center">
     <A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1024&f=S&l=50&d=PTXT&s1=((G06F.CPCL.+AND+(%22intrusion+prevention+system%22+OR+%22intrusion+detection+system%22))+AND+((power+OR+electricity)+OR+relay))&p=20&Query=CPCL/G06F+AND+(&quot;intrusion+prevention+system&quot;+OR+&quot;intrusion+detection+system&quot;)+AND+(power+or+electricity+or+relay)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/prevlist.gif border=0 ALT=[PREV_LIST]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1024&f=S&l=50&d=PTXT&s1=((G06F.CPCL.+AND+(%22intrusion+prevention+system%22+OR+%22intrusion+detection+system%22))+AND+((power+OR+electricity)+OR+relay))&p=21&Query=CPCL/G06F+AND+(&quot;intrusion+prevention+system&quot;+OR+&quot;intrusion+detection+system&quot;)+AND+(power+or+electricity+or+relay)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/hitlist.gif border=0 ALT=[HIT_LIST]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1023&f=G&l=50&d=PTXT&s1=((G06F.CPCL.+AND+(%22intrusion+prevention+system%22+OR+%22intrusion+detection+system%22))+AND+((power+OR+electricity)+OR+relay))&p=21&OS=CPCL/G06F+AND+(&quot;intrusion+prevention+system&quot;+OR+&quot;intrusion+detection+system&quot;)+AND+(power+or+electricity+or+relay)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/prevdoc.gif border=0 ALT=[PREV_DOC]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1025&f=G&l=50&d=PTXT&s1=((G06F.CPCL.+AND+(%22intrusion+prevention+system%22+OR+%22intrusion+detection+system%22))+AND+((power+OR+electricity)+OR+relay))&p=21&OS=CPCL/G06F+AND+(&quot;intrusion+prevention+system&quot;+OR+&quot;intrusion+detection+system&quot;)+AND+(power+or+electricity+or+relay)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/nextdoc.gif border=0 ALT=[NEXT_DOC]></A>

   <A href="#top"><IMG valign="middle" src="/netaicon/PTO/top.gif" border="0" alt="[Top]"></A>
   </TD></TR>
   </TABLE>
   <A name="bottom"></A>
   <A href="/netahtml/PTO/index.html"><IMG src="/netaicon/PTO/home.gif" alt="[Home]" border="0" valign="middle"></A>
   <A href="/netahtml/PTO/search-bool.html"><IMG src="/netaicon/PTO/boolean.gif" alt="[Boolean Search]" border="0" valign="middle"></A>
   <A href="/netahtml/PTO/search-adv.htm"><IMG border="0" src="/netaicon/PTO/manual.gif" alt="[Manual Search]" valign="middle"></A>
   <A href="/netahtml/PTO/srchnum.htm"><IMG src="/netaicon/PTO/number.gif" alt="[Number Search]" border="0" valign="middle"></A>
   <A href="/netahtml/PTO/help/help.htm"><IMG border="0" src="/netaicon/PTO/help.gif" alt="[Help]" valign="middle"></A>
   </CENTER>
</BODY>
</HTML>